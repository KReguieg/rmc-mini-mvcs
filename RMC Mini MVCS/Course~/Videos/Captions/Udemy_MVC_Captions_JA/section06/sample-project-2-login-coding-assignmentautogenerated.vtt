WEBVTT

00:00.180 --> 00:04.080
というわけで、コーディング・チャレンジのひとつに挑戦するために、ここでライブ・コーディングをしてみようと思う。

00:04.080 --> 00:11.250
これはUIにクリアボタンを追加するもので、ログインでもログアウトでもありません、

00:11.250 --> 00:14.510
ユーザー名とパスワードのフィールドをクリアするだけです。

00:14.520 --> 00:19.440
ログアウトボタンも似たようなことをするので、ちょっと作為的な例になってしまいますが

00:19.440 --> 00:26.220
ビューに何か新しいものを追加して、それが正しく伝搬される例を示したいと思います。

00:26.220 --> 00:27.330
というように。

00:27.330 --> 00:30.270
では、まずビュー自体に新しいボタンを追加してみましょう。

00:30.270 --> 00:37.650
プレハブであるこのゲームオブジェクトに新しいボタンを一つ追加します。

00:37.650 --> 00:39.450
クリアボタンと名付けます。

00:40.650 --> 00:42.300
名前を付けます。

00:44.190 --> 00:52.350
そしてログイン画面に戻り

00:52.350 --> 00:56.190
ログインボタンとログアウトボタンが宣言されています。

00:56.190 --> 00:59.490
そのクラスを開きます。

01:00.820 --> 01:06.730
そして、このボタンが視覚的に真ん中に来るように順番を正しく保つようにします。

01:07.360 --> 01:11.770
他の2つのボタンに挟まれるようにします。

01:12.280 --> 01:16.930
unityをリコンパイルさせます。

01:18.540 --> 01:24.810
そしてUIから、クリアボタンが正しく配線されたことを宣言する必要がある。

01:24.810 --> 01:27.000
これで、ビューはこのことを認識します。

01:27.000 --> 01:28.140
シーンを実行してみます。

01:29.440 --> 01:31.690
まず、まだグレーアウトしていないことに注目してください。

01:31.690 --> 01:36.910
もちろんコーディングはしていませんが、ここでクリアボタンをクリックすればクリックされます。

01:36.910 --> 01:38.080
まだ結果は出ていません。

01:39.160 --> 01:41.770
(仝櫃鬚弔い討い襪海箸弔い討い襪海箸弔い討い襪海箸弔い討い襪海箸董

01:41.770 --> 01:43.390
ログインボタンはどうやって使うんだ？

01:43.390 --> 01:44.790
ここです。

01:44.800 --> 01:53.740
コピペして、クリアボタンにして、その構造を真似てみます。

01:53.740 --> 01:54.440
01:53.740 --> 01:54.440

01:54.460 --> 01:56.470
クリアボタンがクリックされる

01:56.980 --> 02:01.060
そのメソッドはまだ存在しないので、ここに降りてくる。

02:04.960 --> 02:05.770
さあ、行くぞ。

02:06.370 --> 02:10.990
ログインボタンの中にカスタムログインイベントがあることがわかります。

02:10.990 --> 02:13.980
クリアボタンにはカスタムクリアイベントを設定します。

02:13.990 --> 02:16.150
では、ここでクリアしてみましょう。

02:18.390 --> 02:20.130
これをオンクリアと呼びます。

02:25.750 --> 02:26.170
さあ、いきますよ。

02:27.580 --> 02:34.420
パラメーターを取らないようにします。

02:34.420 --> 02:36.460
調整する

02:37.520 --> 02:38.420
そして

02:39.680 --> 02:41.990
パラメーターはいらないから。

02:44.520 --> 02:47.550
そして、ベストプラクティスとして、そこに独自のイベントを与えるだけだ。

02:54.680 --> 02:56.420
これでボタンのキャプチャは完了です。

02:56.420 --> 03:00.100
ビューのUIからクリックすると、クリアがディスパッチされます。

03:00.110 --> 03:04.280
本番のプロジェクトでどのように作業するかを真似してみます。

03:04.280 --> 03:05.890
特に、何かと似たような機能を追加する場合はね。

03:05.900 --> 03:10.670
ログインボタンがどのように機能するかを見て、それをコピペしたんだ。

03:10.700 --> 03:12.560
ここも同じパターンで。

03:13.970 --> 03:16.070
使い方を探してみる。

03:25.510 --> 03:32.530
コードエディターのビュー参照やビューの使い方を使って、どこがどうなっているのかを確認するんだ。

03:32.530 --> 03:34.240
ログインイベントが使われるのか？

03:34.240 --> 03:36.310
コントローラ内部で何が使われているのか？

03:36.310 --> 03:38.800
というわけで、この流れも真似してみます。

03:41.310 --> 03:43.890
そして、ここに新しいメソッドを追加します。

03:44.850 --> 03:46.830
これがコントローラーです。

03:59.780 --> 04:04.880
この場合、ビューのイベントをコマンドに変換します。

04:05.300 --> 04:09.820
そこで、送信されたコマンドのソースを見てみます。

04:09.830 --> 04:11.420
私のプロジェクトを見てください。

04:12.390 --> 04:17.130
実は引数はいらないんだ。

04:17.160 --> 04:18.560
のフィールドがクリアされた。

04:18.570 --> 04:24.000
クリアボタンがクリックされても、詳細は一切伝えないということだけはなんとなくわかる、

04:24.000 --> 04:26.820
ただグローバルにクリアすべきものをクリアするだけです。

04:26.820 --> 04:32.490
では、ここではパラメータを取らずにクリアコマンドを作ります。

04:56.690 --> 05:01.200
コントローラーはこのイベントをリッスンし、新しいコマンドを送信します。

05:01.220 --> 05:05.260
今このシーンを実行すれば、すべてがコンパイルされますよね？

05:05.270 --> 05:07.130
クリックをキャプチャします。

05:07.130 --> 05:11.750
クリックは予想通りコントローラに伝搬され、次のように送信されます。

05:11.750 --> 05:14.440
しかし、誰もそのコマンドを聞いていません。

05:14.450 --> 05:17.270
では、誰が聞くべきなのか？

05:17.270 --> 05:19.730
その結果を実際に処理するのは誰なのか？

05:20.390 --> 05:21.440
まあ、見解だよね。

05:21.440 --> 05:23.570
では、ビューを見てみましょう。

05:35.470 --> 05:38.500
ビューに戻り、新しいイベントをサブスクライブします。

06:12.280 --> 06:14.380
クリアコマンドの配線が完了しました。

06:14.380 --> 06:16.470
では、実際に何が起こるか考えてみましょう。

06:16.480 --> 06:19.300
まあ、ログアウトした時と同じようなものだ。

06:19.300 --> 06:20.770
では、ログアウトを見てみよう。

06:24.240 --> 06:27.220
ログアウトはここからコピーしたものです。

06:27.240 --> 06:32.280
ログアウトを実行し、すべてのフィールドを設定します。

06:34.400 --> 06:38.810
だから、ログアウトと同じようなことがしたいんだ。

06:38.810 --> 06:43.400
しかし、新しいものを作るために、これらをここにコピーしよう。

06:45.230 --> 06:46.550
入れ替えるんだ

06:46.760 --> 06:48.290
すでにあるんだろ

06:48.290 --> 06:59.150
ログインはクリアされ、ステータスのテキストはユーザー名を入力するだけです。

06:59.150 --> 07:02.900
とパスワードを入力し、ヒントは入力しない。

07:05.170 --> 07:05.740
そうだ。

07:05.770 --> 07:12.190
さて、もうひとつ、ログインボタンとログアウトボタンを切り替えるたびに

07:12.190 --> 07:15.150
クリアボタンも考えておこう。

07:15.160 --> 07:19.840
では、一番上まで行って、スクロールしてみましょう。

07:20.170 --> 07:22.810
をクリアボタンに更新します。

07:34.850 --> 07:37.340
ログインボタン

07:37.580 --> 07:39.410
ログアウト

07:43.710 --> 07:49.830
クリアボタンは有効にすべきではありません。ログアウトしたときには、すでにクリアされているからです。

07:49.830 --> 07:51.060
クリックできないようにしてください。

07:53.770 --> 07:59.080
もう一度クリアボタンを押しても、2度目はクリアをクリックできないはずです

07:59.080 --> 08:00.910
すでにクリアされているからだ。

08:04.130 --> 08:06.560
クリックするたびにログインします。

08:08.350 --> 08:10.630
できるはずだ。

08:12.760 --> 08:14.020
クリアか？

08:16.030 --> 08:18.190
完全なログイン状態ではない。

08:18.190 --> 08:20.770
デモのためです。

08:22.440 --> 08:25.350
そしてログアウトするたびに

08:26.560 --> 08:29.740
基本的にログアウトとクリアは同じような動作をさせたい。

08:29.740 --> 08:31.450
ログアウトとクリア

08:33.040 --> 08:34.240
そうだね。

08:34.480 --> 08:36.580
ここまでどうなったか見てみよう。

08:38.050 --> 08:40.750
マイクのクリアボタンがグレーアウトしています。

08:43.190 --> 08:48.440
さて、ここでタイピングを始めたら、クリアボタンを有効にしてほしい。

08:48.440 --> 08:49.460
それでは見てみましょう。

09:23.670 --> 09:28.440
UIフィールドが入力されるたびに更新されます。

09:28.440 --> 09:35.820
このメソッドを呼び出すunityイベントがすでにあるので、ログインが許可されるのは、以下の両方の場合だけだ。

09:35.820 --> 09:37.920
フィールドに何か入力されている場合のみ。

09:38.040 --> 09:42.930
つまり、どちらかのフィールドに何か入力されていれば、ログインを許可するということです。

09:42.930 --> 09:43.770
クリアボタンを押す。

09:43.890 --> 09:50.130
これは実装レベルのディテールですが、どのような考え方があるのかを示すことができるのはいいことです。

09:50.130 --> 09:53.490
これは実装レベルの詳細だが、新しいUIを追加する際にどのような考えや決断を下すかを示すことができるのは良いことだ。

09:56.140 --> 09:58.480
ここで再びデモを実行します。

09:59.940 --> 10:04.170
ここで何か入力すると、クリアボタンが有効になる。

10:04.350 --> 10:07.560
フィールドから削除すると無効になります。

10:08.190 --> 10:11.010
パスワードを少し入力すると。

10:11.800 --> 10:15.400
元に戻すとちゃんと使えるようになります。

10:15.670 --> 10:17.740
ここで、両方のフィールドがあったとしよう。

10:17.740 --> 10:23.290
ログインするか、"クリア "をクリックすれば、また正しく機能します。

10:23.290 --> 10:24.640
もう一度入力します

10:25.120 --> 10:31.870
もう一度、ログインするか、クリアをクリックします。

10:31.870 --> 10:33.820
まだテストはしていません。

10:33.820 --> 10:35.890
すべてのコーナーケースを確認したわけじゃない。

10:35.890 --> 10:43.240
しかし、ここでは新しいUIエレメントを追加し、それを伝搬させることがどのようなものかを示したかった。

10:43.240 --> 10:43.720
--> 10:43.720

10:43.720 --> 10:51.670
UIをunityのシーンに入れて、それを

10:51.670 --> 10:58.360
Viewクラス自体に取り込み、Viewをリッスンし、それをコントローラに渡す。

10:58.360 --> 11:00.670
コントローラーが適切なコマンドを送る

11:00.670 --> 11:02.500
そうすることで、全てのことが可能になった。

11:02.500 --> 11:07.990
今、説明しながら進めていたが、これが数分かかるとしよう。

11:08.200 --> 11:15.040
別のアプローチとしては、Viewがunityイベントをリスンし、それ自体を更新するだけで、unityイベントは発生しません。

11:15.040 --> 11:18.250
コントローラーは関与せず、コマンドも関与しない。

11:18.370 --> 11:20.560
そして、ここから始めるのも悪くない。

11:20.560 --> 11:24.790
しかし、その瞬間を捉えることができない。

11:24.790 --> 11:30.160
このような完全なオーケストレーションの流れができるのは、とてもいいことだ。

11:30.160 --> 11:31.960
を聴くことができるのだろうか？

11:31.990 --> 11:34.210
クリアボタンが押されたのか？

11:34.210 --> 11:38.200
そういうメッセージは必要な時と必要でない時がある。

11:38.200 --> 11:44.860
つまり、MVCを学びながら、どのようにするかはあなた次第なのです。

11:44.860 --> 11:49.450


11:49.450 --> 11:53.310
このコーディングの割り当てをサンプルに追加するのは以上だ。

11:53.320 --> 11:54.130
ありがとうございました。
