WEBVTT

00:00.180 --> 00:03.600
MVCが多い時計のサンプル。

00:04.290 --> 00:06.390
ここは空のプロジェクトの中です。

00:06.390 --> 00:10.800
MiniとVCのフレームワークを追加し、サンプルをインポートしました。

00:11.010 --> 00:15.690
ここで、MVCがたくさんあるバージョンの時計を見てみましょう。

00:15.930 --> 00:17.760
まずはサンプルを実行してみます。

00:21.160 --> 00:21.460
ここで

00:21.460 --> 00:27.820
UIは何も表示されていませんが、デバッグ・ログ・コンソールにデバッグ・ログが表示されています。

00:27.820 --> 00:32.020
シーンが開いている間の経過時間が表示されています。

00:32.440 --> 00:33.130
以上です。

00:33.130 --> 00:36.090
UIも入力機能もありません。

00:36.100 --> 00:38.650
ファイル構造を初めて見ました。

00:38.650 --> 00:42.760
サンプルスクリプトはシーンのゲームオブジェクトに置いてあります。

00:42.760 --> 00:48.130
時計のミニクラスが作成され、すべての関心事を含んでいます。

00:48.130 --> 00:54.940
そして、モデル、ビュー、コントローラー、サービスといったそれぞれの関心事に関連するクラスがあります。

00:54.940 --> 00:58.900
さらに、まだ説明していない概念として、コンテキストがあります。

00:58.900 --> 01:02.690
このコードを見ながら、コンテキストの役割を見てみましょう。

01:02.710 --> 01:04.750
これがミニサンプルです。

01:08.980 --> 01:10.210
動作の一例です。

01:10.210 --> 01:15.090
ミニクラスのオブジェクトをインスタンス化し、initializeを呼び出します。

01:15.100 --> 01:16.830
これが時計のミニクラスです。

01:16.840 --> 01:20.200
ミニクラスとVCフレームワーククラスを継承しています。

01:20.410 --> 01:24.990
これは、4つの関心事をすべて保持する親オブジェクトと考えることができます。

01:25.000 --> 01:31.990
これは一般的なクラスで、コンテキストのモデル、ビュー、コントローラーの強い型を渡します。

01:31.990 --> 01:32.830
とサービスを渡す。

01:32.830 --> 01:37.240
ミニMVCの構造で初期化を行います。

01:37.240 --> 01:41.980
関係する主要な部分はすべて明示的に初期化された呼び出しを持っています。

01:41.980 --> 01:47.530
これは、システムがウェイクアップするときに一度だけ発生するコードを置くのに最適な場所だ。

01:47.530 --> 01:49.110
ここで何をする？

01:49.120 --> 01:55.900
まず、初期化されていることを確認し、コンテキストモデル、ビュー、コントローラを作成する。

01:55.900 --> 01:56.770
とサービスを作成します。

01:56.800 --> 02:01.810
それぞれのコンストラクタはコントローラ以外の引数を取らないことに注意してください。

02:01.960 --> 02:09.940
これは、コントローラーが最も強力で有能であることを示す最初の例の一つです。

02:09.940 --> 02:15.820
コントローラはモデル・ビューを統合する接着剤の役割を果たすからです。

02:15.820 --> 02:20.350
サービスでは参照を渡すので、それをどのように管理し、扱うかを知っています。

02:20.350 --> 02:25.150
そして最後に、ベストプラクティスに従って各コンサーンを初期化する。

02:25.180 --> 02:29.790
まだコンテキストの話はしていない。

02:29.800 --> 02:30.970
見てみよう。

02:31.000 --> 02:33.340
コンテキストはフレームワークのクラスです。

02:33.340 --> 02:39.100
AIコンテキストのインターフェイスを実装しており、他のシステムはそのインターフェイスを探します。

02:39.100 --> 02:45.190
つまり、そのインターフェイスを実装するだけで、コンテキストの代わりになるものを自由に作ることができるわけだ。

02:45.190 --> 02:49.900
しかし、私の用途では、この基本的な実装が大抵の場合私のニーズを満たしてくれる。

02:49.900 --> 02:52.000
この実装には2つだけある。

02:52.000 --> 02:58.150
モデルロケータとコマンドマネージャがある。

02:58.150 --> 02:59.950
インスタンス化時に作成される

02:59.950 --> 03:01.600
コンタクトの役割は？

03:01.600 --> 03:08.590
コンテキストは、4つの関心事のすべてが参照するメッセージングシステムと考えることができます。

03:08.620 --> 03:10.720
どのようなことができるのでしょうか？

03:10.720 --> 03:16.150
コマンドマネージャーを使えば、どんなコマンドでも聞くことができるし、どんなコマンドでも呼び出すことができる。

03:16.150 --> 03:18.880
これがメッセージング部分とモデルロケーターだ。

03:18.880 --> 03:25.390
より高度なコンセプトとして、任意のモデルを登録し、そのモデルを検索することができます。

03:25.390 --> 03:31.690
つまり、モデルを登録したり、モデルのイベントをリッスンしたりすることができるのだ。

03:31.690 --> 03:37.480
コンストラクタでは、この2つの部分がインスタンス化されます。

03:37.480 --> 03:40.300
ということです。

03:40.690 --> 03:48.430
これにより、どのスコープでも、ここにあるようなコンテキストを追加することができ、他のどのコンサルトもそのコンテキストを取得することができる。

03:48.430 --> 03:49.000
必要であれば

03:49.000 --> 03:51.160
もっと複雑な例を見てみよう。

03:51.160 --> 03:57.130
これは、プロジェクトに2つの異なるミニMV軸があり、その間を通信したい場合に便利です。

03:57.130 --> 04:01.570
この最初のサンプルでは、そのような複雑なことには触れませんので、この詳細は無視してかまいません。

04:01.570 --> 04:05.920
これでこの例全体のハイレベルな議論は終わりです。

04:05.920 --> 04:12.490
ミニ親オブジェクトは4つの関心事を内包しており、それぞれの関心事には

04:12.490 --> 04:14.890
上位レベルからのコンテキストへの参照。

04:14.890 --> 04:17.800
その基本概念を理解することが重要なのだ。

04:17.800 --> 04:22.330
この部分を再視聴して理解を深めてください。

04:22.330 --> 04:25.720
では、それぞれの懸念事項を確認し、それがどのように作用するかを見ていこう。

04:25.720 --> 04:28.600
文脈はすでに見ましたので、モデルを見てみましょう。

04:28.600 --> 04:31.030
これはコードで見た最初の懸念事項です。

04:31.030 --> 04:36.910
どのように構築されているのか、さらに詳しく見てみましょう。

04:36.910 --> 04:41.080
そして、他のサンプルの他の懸念事項のほとんども同じようなパターンに従っている。

04:41.080 --> 04:44.630
そのため、今後の議論では、これほど深く取り上げることはないだろう。

04:44.650 --> 04:47.790
時計モデルがベースモデルを拡張していることに注目してください。

04:47.800 --> 04:51.760
ベースクラスの拡張はオプションです。

04:51.760 --> 04:56.620
しかし、もしあなたがそれを望むのであれば、別の方法でアプローチすることもできます。

04:56.620 --> 04:57.700
もっと柔軟性が欲しいなら

04:57.700 --> 05:03.160
つまり、ここで提案された慣例はあるが、あなた独自の解決策を講じる柔軟性があるということだ。

05:03.160 --> 05:04.660
ベースモデルを見てみましょう。

05:04.660 --> 05:08.920
ベースモデルはIモデルを実装しています。

05:08.920 --> 05:14.770
フレームワークの将来のバージョンでは、このモデルに対して何かカスタムなことをする可能性はあるが

05:14.770 --> 05:18.670
しかし、今のところ、それは他の懸念ができることを模倣するだけです。

05:18.670 --> 05:25.570
そのため、このインターフェイスを実装したクラスはすべて

05:25.570 --> 05:32.080
初期化メソッドでコンテキストを受け取って初期化することができる。

05:32.080 --> 05:35.620
そのコンテキストのパブリックプロパティを保持する。

05:35.620 --> 05:42.070
このように、4つの懸念事項のすべてが可能である。

05:42.070 --> 05:47.560
モデルの使い方はコントローラの使い方とは異なりますが、その中身は同じです。

05:47.560 --> 05:48.130
できる。

05:48.130 --> 05:50.350
繰り返しになるが、これが究極の柔軟性を可能にしている。

05:50.350 --> 05:55.720
クロックモデルがベースモデルを拡張していることがわかる。

05:55.720 --> 05:57.640
時計モデルの残りの動作を見てみよう。

05:57.640 --> 06:01.600
モデルはすべてのランタイムデータのデータストアと考えることができる。

06:01.600 --> 06:03.640
では、時計の例では何が必要なのか？

06:03.640 --> 06:05.440
現在の時刻が必要です。

06:05.440 --> 06:08.200
そして、この例では遅延を維持します。

06:08.300 --> 06:10.280
時計の針と針の間

06:10.280 --> 06:17.160
1秒、2秒、3秒と表示される。

06:17.160 --> 06:18.110
秒と表示される。

06:18.110 --> 06:24.410
モデルには、他の懸念事項と同様に、初期化機能があり、ここで行う唯一のカスタム機能は初期化だけである。

06:24.410 --> 06:26.960
観測変数の値です。

06:26.960 --> 06:28.280
これで時計モデルは完成だ。

06:28.280 --> 06:30.050
次に時計ビューを見てみましょう。

06:30.050 --> 06:38.720
時計ビューはアイ・ビューを実装しています。

06:38.720 --> 06:41.060
を実行し、コンテキストを取得する。

06:41.060 --> 06:42.530
というわけで、これ以上は調べない。

06:42.530 --> 06:46.310
ベースとなる機能は必要ないので、ここではベースクラスは使いません。

06:46.310 --> 06:48.110
ビューを実装するだけです。

06:48.110 --> 06:52.730
プロパティとフィールドを用意し、初期化を行います。

06:52.730 --> 06:56.450
これは、あらゆる懸念事項に対する定型的なものです。

06:56.450 --> 06:59.720
ここで行う唯一のカスタムは、コンテキストを使用することです。

06:59.720 --> 07:05.150
これは、コマンド・マネージャーにアクセスし、カスタム・コマンドをリッスンする最初の例だ。

07:05.150 --> 07:07.910
コマンドをリッスンしている。

07:07.910 --> 07:12.800
コマンドマネージャーがこのコマンドを呼び出したら、いつでもここでそのコマンドを聞くことができる。

07:12.800 --> 07:15.590
コマンドマネージャーの動きを見る最初のチャンスだ。

07:15.590 --> 07:20.300
コマンドとイベントの違いを覚えておこう。

07:20.300 --> 07:24.260
誰がこのようなメッセージを送るのか知る必要はない。

07:24.260 --> 07:28.460
コマンドマネージャーという中間管理者にサブスクライブするだけです。

07:28.520 --> 07:30.230
これは分離されたソリューションです。

07:30.230 --> 07:31.640
各コンサーンが実装します。

07:31.640 --> 07:33.800
必須は初期化される。

07:33.800 --> 07:40.700
これは、MVCフレームワーク特有のものというより、私が使っているベストプラクティスですが、私はただ

07:40.700 --> 07:46.070
初期化されているかどうかを簡単にチェックするメソッドを作り、初期化されていなければ例外を投げる。

07:46.070 --> 07:50.690
このメソッドは、すべてのメソッドの先頭で使われます。

07:50.690 --> 07:55.250
パブリック・メソッドの呼び出しが早すぎないかチェックするための簡単な方法です。

07:55.250 --> 08:00.860
さて、コマンドマネージャーが関連するイベントをディスパッチするたびに、私たちはここでそれを処理します。

08:00.860 --> 08:04.760
まず最初に初期化されていることを確認します。

08:04.760 --> 08:08.600
シーンが実行されるたびに初期化されることを期待しています。

08:08.600 --> 08:13.460
これは、ライフサイクルが正しく動作しているかどうかを確認するための追加のゲートチェックです。

08:13.460 --> 08:17.000
そして、デバッグのためのカスタム機能です。

08:17.000 --> 08:17.600
ログアウト。

08:17.600 --> 08:22.430
画面上にUIはなく、モンテのビヘイビアも使っていない。

08:22.430 --> 08:26.960
だから、Viewを通して発言する方法は、デバッグログ文を使うだけだ。

08:26.960 --> 08:31.760
これは、プロジェクトでログをデバッグするたびにこの手順を踏む必要があるという意味ではありません。

08:31.760 --> 08:35.600
一般的なプロジェクトと同じように、自由にやってください。

08:35.600 --> 08:43.070
これは、モノの挙動を伴わない、ある種のユーザーのフィードバックを示すために作られた、作為的な例です。

08:43.070 --> 08:46.070
また、UIもシンプルである。

08:46.070 --> 08:47.900
次に時計サービスを見てみよう。

08:47.900 --> 08:50.330
時計サービスはベースサービスを拡張しています。

08:50.330 --> 08:57.380
基本クラスを拡張するすべての懸念事項がそうであるように、それは初期化を行うだけです。

08:57.380 --> 09:01.280
とコンテキストのセットアップを行うだけである。

09:01.280 --> 09:06.890
このサービスは何かをロードし、ロードが完了したらシステムに通知するように設計されています。

09:06.890 --> 09:08.960
カスタムユニティイベントです。

09:08.960 --> 09:12.650
このサービスから実際に読み込まれるデータは時間遅延です。

09:12.650 --> 09:14.120
ここで利用できるようになります。

09:14.120 --> 09:17.930
initializeの中では、基本的な懸念事項の設定を行っています。

09:17.930 --> 09:23.120
この中で唯一カスタムなのは、時間遅延を初期化することです。

09:23.120 --> 09:24.830
スコープのロードが呼び出される。

09:24.830 --> 09:31.310
そして、ここで見られるのは、ミニMVCでないバージョンの機能と非常によく似ている。

09:31.310 --> 09:32.060
以前

09:32.240 --> 09:36.470
ローカルのテキストファイルを読み込んで、そこから文字列の値を取り出します。

09:36.470 --> 09:38.300
int型で保存してくれる

09:38.300 --> 09:43.100
データが読み込まれると、loadedイベントが発生します。

09:43.100 --> 09:46.370
どのスコープがそのイベントを消費するのか、まだ見ていない。

09:46.370 --> 09:46.670
次です。

09:46.670 --> 09:47.900
コントローラを見てみましょう。

09:47.900 --> 09:53.510
これはこのサンプルの最も複雑な問題であり、多くのサンプルではコントローラーに

09:53.510 --> 09:58.100
クロックコントローラはベースコントローラを継承しています。

09:58.100 --> 10:01.640
ベースクラスが使用されている場合はすべてオプションです。

10:01.640 --> 10:05.360
もちろん、コントローラを実装した独自のクラスを作ることもできます。

10:05.360 --> 10:11.180
しかし、ここではいくつかの基本的な機能を提供している。

10:11.180 --> 10:11.870
となる。

10:11.870 --> 10:17.090
クロックコントローラーは特定の引数を扱うので、ベースコントローラーは

10:17.090 --> 10:22.670
ジェネリックとし、モデルビューとサービスには強く型の値を渡します。

10:22.670 --> 10:26.870
コンストラクタでは、モデルビューとサービスを基底クラスに渡します。

10:26.870 --> 10:32.450
initializeでは、すべての懸念が行う典型的なことを行います。

10:32.450 --> 10:34.250
10:32.450 --> 10:34.250

10:34.430 --> 10:40.220
ここで行っている唯一のカスタム処理は、モデルをリッスンし、observableの一つを購読することである。

10:40.220 --> 10:44.150
イベントと、サービスがいつロードされたかを知るためにサービスをリッスンすることである。

10:44.150 --> 10:49.040
さて、ここまでobservableの概念について説明し、モデルのソースコードを見てきた。

10:49.040 --> 10:55.220
observableクラスからUnityのイベントを購読するのを見たのはこれが初めてです。

10:55.220 --> 11:03.140
つまり、どのスコープからでも、モデルの時間値が設定されると、この時間値の変更に関するイベントが発生することになる。

11:03.410 --> 11:08.180
繰り返しになるが、observablesの使用はオプションだが、すべての人に推奨される。

11:08.510 --> 11:15.710
モデル内のプロパティは、値を設定することができるという自動的なパラダイムを得ることができます。

11:15.710 --> 11:18.560
その値がいつ設定され、いつ変更されたかを知ることができる。

11:18.560 --> 11:25.310
そのため、そのサービスがロードされると、そのサービスが外部から取得した値に基づいてモデルを更新する。

11:25.310 --> 11:25.700
データを更新する。

11:25.700 --> 11:27.530
そして、時計の針が動き始めます。

11:27.530 --> 11:32.960
時計の針は、ミニじゃないNBCのバージョンで見たのとよく似た動きをする。

11:32.990 --> 11:34.700
しかし、重要な違いがある。

11:34.700 --> 11:40.730
先ほど、unityエンジンのいくつかの領域で、unityがどのようにモデル・ビュー・コントローラーを崩壊させるかについて話しました、

11:40.730 --> 11:45.590
そのうちの1つは、monoの動作自体が非常に強力で、多くの関心事にまたがっているということです。

11:45.590 --> 11:52.070
さて、ミニMVC以外の例では、繰り返し可能なコードを呼び出すためにCOルーチンを使いました。

11:52.070 --> 11:54.200
この例ではモノビヘイビアは使っていません。

11:54.200 --> 11:58.040
今はCOルーチンにアクセスすることはできません。

11:58.040 --> 12:00.140
"偽装 "する方法はいくらでもある

12:00.140 --> 12:05.600
ここで私が選択したのは、好きなように自由に掘り下げることができる別のクラスだ。

12:05.600 --> 12:08.060
このクラスは反復可能なコードを呼び出すだけだ。

12:08.060 --> 12:10.430
この例ではClock Helperと呼んでいる。

12:10.430 --> 12:15.110
これがどのように機能するかはこの例の範囲外だが、次のように呼び出す方法の回避策であることだけは知っておいてほしい。

12:15.110 --> 12:15.950
反復可能なコード

12:15.950 --> 12:17.900
そして、それは私が採用した解決策のひとつだった。

12:17.900 --> 12:23.210
ここで重要なのは、コントローラーの中で、タイムディレイが発生するたびに

12:23.210 --> 12:26.030
毎秒、モデルデータをセットしている。

12:26.030 --> 12:29.210
つまり、コントローラーがモデルに値を設定しているわけだ。

12:29.210 --> 12:34.760
そして、モデルの値が変更されるたびにunityイベントをリッスンしているので、次のようになります。

12:34.760 --> 12:35.270
コールバック

12:35.270 --> 12:41.180
つまり、ここではコントローラの中で、モデルの変更をサブスクライブし、それを処理し、それを

12:41.180 --> 12:42.050
コマンドに変換する。

12:42.050 --> 12:45.860
これはMVCでよく見られるパターンだ。

12:45.860 --> 12:52.910
これはMVCでよく見られるパターンです。

12:53.030 --> 12:59.570
コマンドは、どの関係者からも観察され、聞くことができる。

12:59.570 --> 13:02.570
コンテキストにアクセスできる。

13:02.570 --> 13:10.190
だから、invokeコマンドを見るときはいつでも、それはラジオ局のようなメッセージだと思えばいい。

13:10.190 --> 13:11.030
13:10.190 --> 13:11.030

13:11.030 --> 13:13.340
これは非常に強力なコンセプトだ。

13:13.340 --> 13:18.620
このコンセプトは非常に強力だ。

13:18.620 --> 13:25.040
さて、このように非常に柔軟ではあるが、我々は基本的な慣習に従いたい。

13:25.040 --> 13:30.110
コマンドを送受信することになるが、例外も存在する。

13:30.110 --> 13:35.900
|にできるようにあなたがそれをすることができます本当に出くわすことあなたは、実際には私のパートナーとi約束、誰でも素早くはちょうど無視これらの一見正確にどのように{}人のことを忘れることができます。

13:35.900 --> 13:38.510
MVCを使う技術の一部です。

13:38.510 --> 13:41.180
以前のスライドで、私は規約を提案しました。

13:41.180 --> 13:42.770
それに従うのは自由だ。

13:42.770 --> 13:46.490
ただ、例外を適用する場合は一貫性を保つことをお勧めします。

13:46.490 --> 13:47.210
以上です。

13:47.210 --> 13:52.730
ここまで、コンテキスト、モデル、ビュー、コントローラ、サービスの作成について説明しました。

13:53.000 --> 13:55.910
そして、それらを初期化します。

13:56.180 --> 14:02.240
タイムラインから見ると、シーンに君主のビヘイビアがあり、その開始時に

14:02.240 --> 14:05.630
ミニの初期化でミニを作成しました。

14:05.630 --> 14:11.660
このように、さまざまなパーツを配線して、初期化します。

14:11.660 --> 14:17.450
この例では、コントローラーが初期化されるとき、私はそれがどのように動作するかを知っているので、私は知っている、

14:17.450 --> 14:22.190
この例では、コントローラーが初期化されたときに、カチカチと音が鳴り始める。

14:22.190 --> 14:23.960
コードの概要は以上です。

14:23.960 --> 14:27.740
おそらくこれが最も濃いコードサンプルでしょう。

14:27.740 --> 14:32.000
シンプルなサンプルにもかかわらず、ここにはたくさんのコンセプトが詰まっています。

14:32.000 --> 14:36.770
今までのスライドで見てきた理論を全てまとめています。

14:36.770 --> 14:39.950
もう一度、このシーンでサンプルの動きを見てみましょう。

14:39.950 --> 14:46.700
ゲームオブジェクトを選択しました。インスペクタを見ると、そのゲームオブジェクトにはちょうどサンプルが表示されています。

14:46.700 --> 14:47.660
サンプルを実行します。

14:51.590 --> 14:59.960
1000ミリ秒の遅延が発生するたびに実行されるので、1秒間に1ティックということになります。

15:00.710 --> 15:03.770
コンソールにデバッグログが表示されます。

15:04.540 --> 15:06.430
これが完全な例だ。

15:06.610 --> 15:11.020
モデル・ビュー・コントローラー・サービスの概念は全て理解できました。

15:11.680 --> 15:17.230
このように、モデル・ビュー・コントローラー・サービスの概念について見てきました。

15:17.230 --> 15:23.770
そして，学んだ理論を実際のC-sharpのコードに応用するための素晴らしい基礎ができました。

15:24.100 --> 15:26.740
これが最初の完全なサンプルです。

15:26.740 --> 15:29.710
ミニMVCで動くコードを見る。

15:29.710 --> 15:36.520
ユースケースはとてもシンプルですが、やっていることは毎秒デバッグログを記録することだけです。

15:36.520 --> 15:39.730
それを実現するためのコンセプトがたくさんあることがわかります。

15:39.730 --> 15:46.240
これは、多くのMVCのようにオーダーメイドのアーキテクチャを使用する場合の最初の例です、

15:46.270 --> 15:47.860
冗長に感じる

15:47.860 --> 15:54.160
|にできるようにあなたがそれをすることができます本当に出くわすことあなたは、実際には私たち約束、誰でも素早くはちょうど無視これらの一見正確にどのように{}人のことを忘れることができます。

15:54.160 --> 15:54.670
バージョン？

15:54.670 --> 15:58.060
しかし、我々はソフトウェアに投資したいのだ。

15:58.060 --> 16:04.360
ベストプラクティスを使いたいし、10分で理解できるような例ではない。

16:04.360 --> 16:11.140
10日後のプロジェクト、10ヶ月後のプロジェクトで、適切なコード分離をすることで、最大限の力を発揮することができる。

16:11.140 --> 16:15.780
16:11.140 --> 16:15.780 オーダーメイドフレームワークは信じられないほど強力で、配当がある。

16:15.790 --> 16:16.930
今はここまで。

16:16.930 --> 16:17.650
ありがとう。
