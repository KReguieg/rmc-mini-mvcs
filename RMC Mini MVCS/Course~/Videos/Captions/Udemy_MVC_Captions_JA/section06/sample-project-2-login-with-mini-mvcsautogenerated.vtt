WEBVTT

00:00.150 --> 00:04.260
まず、MVCをあまり追加していないバージョンを見てみよう。

00:05.180 --> 00:08.070
ここは空のunityプロジェクトの中です。

00:08.090 --> 00:13.370
ミニNPCフレームワークを追加し、サンプルもインポート済みです。

00:13.670 --> 00:15.650
ログインサンプルを開いてみましょう。

00:16.830 --> 00:22.710
このサンプルのmini MVCを追加していないバージョンのファイル構造です。

00:23.280 --> 00:29.820
リソースセクションには、UIに使用するプレハブと、UIに使用するテキストファイルがあります。

00:29.820 --> 00:32.550
をロードしています。

00:33.180 --> 00:38.700
シーンは1つで、そのシーンにはサンプルファイルが1つあります。

00:39.090 --> 00:40.920
まずはサンプルを実行してみましょう。

00:41.220 --> 00:44.550
このサンプルはログインのオフラインシミュレーションです。

00:45.030 --> 00:50.460
ユーザー名とパスワードを入力するおなじみのパターンです。

00:50.940 --> 00:52.560
ログインボタンをクリックします。

00:52.560 --> 00:57.330
通常、バックエンドのサービスはこれらのフィールドが正しく一致するかどうかを検証する。

00:58.290 --> 01:03.300
この場合、ローカルのファイルを読み込んで、ローカルのパスワードが私が設定したものと一致するかどうかをチェックしている。

01:03.330 --> 01:04.260
を入力します。

01:04.710 --> 01:07.890
では実際にやってみましょう。

01:19.820 --> 01:23.960
パスワードのヒントが表示されます。

01:30.490 --> 01:35.890
ログインを押すと、少し遅れてログインに成功します。

01:53.070 --> 01:57.540
ログアウトしたので、今度は明らかに間違ったパスワードでログインしてみます。

02:00.680 --> 02:02.640
ログインに失敗しました。

02:02.660 --> 02:04.410
これで全てうまくいきました。

02:04.430 --> 02:06.950
このようになるためのコードを見てみましょう。

02:06.950 --> 02:09.500
まずはハイレベルなサンプルファイルから。

02:10.380 --> 02:12.380
これがサンプルファイルのコードです。

02:12.390 --> 02:17.310
まずはスクロールダウンして、一行ずつチェックしていきます。

02:44.380 --> 02:49.690
まずはメインのサンプルクラスではなく、ヘルパーのデータオブジェクトから始めます。

02:51.310 --> 02:56.260
このユーザー・データ・オブジェクトはユーザー名とパスワードを保持しています。

02:56.530 --> 03:01.780
他の例と同じように、ビヘイビアのマウントを拡張することで、次のようにアタッチすることができます。

03:01.780 --> 03:03.080
ゲームオブジェクトに取り付けることができます。

03:03.100 --> 03:07.990
そして、スタート内部のさまざまなUI要素のフィールドがシリアライズされます。

03:07.990 --> 03:14.380
ここでは、UIに組み込まれたunityイベントをサブスクライブし、ログアウトのクリックを真似ています。

03:14.380 --> 03:17.160
ボタンをクリックしてログアウト関数を呼び出します。

03:17.170 --> 03:19.870
これでUIがクリアされ、新しいスタートを切ることができます。

03:19.900 --> 03:26.890
次に、この2つの入力フィールドが編集されるたびに、この関数が呼び出され、単純に更新されます。

03:26.890 --> 03:28.840
投稿はまだですか？

03:28.840 --> 03:33.670
これはとても簡単なチェックですが、もしフィールドが空なら、投稿はできないと言っているだけです。

03:33.670 --> 03:36.610
空欄があれば送信できます。

03:36.760 --> 03:40.510
ログインをクリックするとこうなります。

03:40.510 --> 03:44.200
これが最も重要なメソッドなので、セクションごとに順を追って説明します。

03:44.350 --> 03:48.430
まず、ユーザーがフィールドに入力した内容に基づいて、新しいユーザーデータを作成します。

03:48.430 --> 03:54.500
そして、UI要素ごとに難易度、つまり無効かどうかを切り替えます。

03:54.520 --> 04:00.820
さて、前のサンプルで見たように、オンラインバックエンドコールをシミュレートするには、単に

04:00.820 --> 04:02.080
ローカルテキストファイル

04:02.200 --> 04:05.320
これは非同期処理です。

04:05.320 --> 04:12.190
これは外部データであり、サービスレイヤーのコンポーネントとしては理にかなっている。

04:12.250 --> 04:17.950
最後に、有効なパスワードのテキスト表現が得られることがわかる。

04:17.950 --> 04:20.710
そして、ユーザーが送信したものと照合しています。

04:21.970 --> 04:23.050
一致したとして

04:23.050 --> 04:25.180
ログイン成功とします。

04:25.420 --> 04:31.570
UIを適宜有効にして、成功か失敗かのメッセージを表示します。

04:31.570 --> 04:32.380
を表示します。

04:32.410 --> 04:38.770
最後に、ユーザーがログアウト・ボタンを押した場合は、いつでもこれをスタート・メソッドに反映させます。

04:38.770 --> 04:39.560
このフォームを呼び出します。

04:39.580 --> 04:42.280
最初はUIをクリアするだけです。

04:42.310 --> 04:43.890
もう一度例を実行してみましょう。

04:43.900 --> 04:48.790
正常に動作する作業情報を入力して、デモは完了です。
