WEBVTT

00:00.150 --> 00:04.260
まず、MVCをあまり追加していないバージョンを見てみよう。

00:05.260 --> 00:11.860
ここでは、空のunityプロジェクトにミニMVCフレームワークとサンプルを追加しています。

00:12.070 --> 00:18.040
Rollerballゲームのフォルダ構造を見てきました。

00:18.040 --> 00:19.490
をご覧下さい。

00:19.510 --> 00:20.640
さっそく飛び込んでみましょう。

00:20.650 --> 00:23.330
まずはこのシーンを再生してみましょう。

00:23.350 --> 00:28.840
UIが更新され、スコアが0になり、矢印キーを使うように指示されました。

00:28.840 --> 00:31.510
リスタートボタンもあります。

00:32.320 --> 00:36.430
矢印キーでボールを動かします。

00:38.280 --> 00:42.660
動画では聞こえないかもしれませんが、ボールを集めるたびに音が鳴ります。

00:42.660 --> 00:49.170
また、UIのスコアにも反映され、ステータスが勝利に変わりました。

00:49.170 --> 00:51.900
試合は終了し、入力もできなくなった。

00:51.900 --> 00:55.170
キー入力ができなくなりましたが、リスタートボタンをクリックします。

00:55.170 --> 00:58.080
再起動ボタンを押すと、プロンプトが表示されます。

01:01.230 --> 01:02.520
確認します。

01:05.820 --> 01:10.020
確認すると、まだプレイしていなかったかのようにゲームが再開され、再びプレイできるようになる。

01:10.830 --> 01:11.520
以上です。

01:12.000 --> 01:13.850
例のスクリプトです。

01:13.860 --> 01:19.170
他の例と同様に、高レベルのサンプル・スクリプトはmonoの動作を拡張しています。

01:19.170 --> 01:22.170
こうすることで、シーン内のゲームオブジェクトの上に置くことができます。

01:22.170 --> 01:28.200
ここでは3つのフィールドをシリアライズしています。

01:28.200 --> 01:34.020
プレイヤー用のゲームオブジェクト、UI用のゲームオブジェクト、シーン内のすべてのピックアップオブジェクトのリストにアクセスできます。

01:34.020 --> 01:36.480
また、ゲームオブジェクトの状態も管理しています。

01:36.510 --> 01:38.460
現在、ゲームは終了していますか？

01:38.460 --> 01:42.960
01:38.460→01:42.960現在ポーズ中か？

01:43.740 --> 01:46.770
その他、スタートメソッドでの採点値もあります。

01:46.770 --> 01:53.130
ゲームのメインスクリプトから、プレイヤーのUIに表示されるいくつかの重要なイベントに対して、01:46.770 --> 01:53.130

01:53.130 --> 01:58.290
シーンが動いている間、毎フレーム実行されるupdateが、ゲームのコアループです。

01:58.290 --> 02:04.080
ゲームが終了したり、一時停止した場合は、ループから抜けるので、それ以降は何も起こりません。

02:04.080 --> 02:07.590
このスクリプトでピックアップを制御しています。

02:07.590 --> 02:13.590
このスクリプトは全てのピックアップをループさせ、rotateを呼び出します。

02:13.590 --> 02:18.750
例えば、ピックアップの中ではなく、ここで回転させるのは、ゲームが

02:18.750 --> 02:21.450
一時停止した時にピックアップも一時停止するようにするためです。

02:21.450 --> 02:27.270
そして最後に、ゲームスコープからユーザーの入力を取り込み、それをプレイヤーに伝える。

02:28.890 --> 02:34.230
loadメソッドでは、ローカルのテキストファイルからロードして、ボールを転がすのに必要な最大点数を求めます。

02:34.230 --> 02:34.650
勝利

02:34.650 --> 02:40.380
これまでのデモで見てきたように、3という数字を読み込む。

02:40.380 --> 02:41.730
サービスレイヤーを使うための口実です。

02:41.730 --> 02:43.770
ミニMVCバージョンを見てみましょう。

02:43.770 --> 02:49.590
もちろん、この値をハードコードすることもできますが、ここでは例としてスクリプトから読み込むことにします。

02:49.590 --> 02:50.520
外部データの例です。

02:50.520 --> 02:56.760
定期的にUIを更新したい場合は、このメソッドを呼び出せばよい。

02:56.760 --> 03:00.990
UIボタンがクリックされると、このメソッドが実行されます。

03:00.990 --> 03:07.530
ゲームを一時停止し、画面上にダイアログウィンドウを表示します。

03:07.530 --> 03:12.570
ユーザーがクリックしたら、ダイアログでキャンセルし、その結果を処理する。

03:12.570 --> 03:16.920
ピックアップに衝突するたびにゲームを再開することをユーザーが確認した場合。

03:16.920 --> 03:21.630
このメソッドが呼ばれると、ピックアップオブジェクトは見えなくなり、音が鳴ります。

03:21.630 --> 03:28.800
スコアは0→1→2→3とカウントアップされ、必要な最大値に達すると

03:28.800 --> 03:32.090
普通は3点で、その時点で試合は終了し、あなたの勝利となります。

03:32.100 --> 03:34.050
ゲームロジックは以上です。

03:34.050 --> 03:35.760
シーンの階層を見てみよう。

03:35.760 --> 03:41.640
シーン階層で、ゲームの例そのものを選択すると、いくつかのシリアライズされたフィールドが表示されます。

03:41.640 --> 03:47.130
プレイヤー、UI、シーン内の各ピックアップへの参照を含む。

03:47.130 --> 03:52.800
プレイヤーはプレイヤースクリプトと一緒にここにあり、UIはUIスクリプトと一緒にここにあります。

03:52.800 --> 03:55.860
を同じ親ゲームオブジェクトの下に保存しています。

03:55.860 --> 03:57.630
各ピックアップスクリプトが上にあります。

03:57.630 --> 04:01.170
最後にもう一度ゲームが動いているところを見てみましょう。

04:01.170 --> 04:03.150
この辺をうろうろしてみよう。

04:03.360 --> 04:06.780
ピックアップが回転しています。

04:09.370 --> 04:14.950
プロンプトが表示されている状態で再起動ボタンをクリックすると......、

04:14.950 --> 04:21.220
キューブは回転していません。小さなことですが、このゲームが

04:21.220 --> 04:26.710
を保存しているのだ。

04:26.710 --> 04:29.710
ピックアップに勝ったら回転も止めて見る。

04:36.290 --> 04:42.290
ピックアップに勝つと回転が止まり、ゲームオーバーのような状態になります。

04:42.290 --> 04:48.050
些細なことのように思えるが、このように懸念事項をスムーズにオーケストレーションすることで

04:48.050 --> 04:49.850
シンプルで良いゲームデザインだ。
