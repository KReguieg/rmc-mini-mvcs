WEBVTT

00:00.150 --> 00:06.650
ここでは空のunityプロジェクトで、多くのNPCのフレームワークを追加し、サンプルをインポートしています。

00:06.660 --> 00:10.170
Miniを入れたバージョンのフォルダ構成です。

00:10.770 --> 00:15.360
このフォルダ構造は以前のサンプルでも見たことがあるので、詳しくは説明しません。

00:15.360 --> 00:20.400
ひとつ言っておきたいのは、デモのためにピックアップ・コンポーネントを

00:20.430 --> 00:24.750
構造的にはミニMVCの外側にあり、コードの中にある。

00:24.750 --> 00:26.880
サンプルの概要で、その理由を述べます。

00:26.880 --> 00:29.460
まずはメインのサンプル・スクリプトを開きましょう。

00:29.460 --> 00:34.200
先ほどと同じように、メインのサンプル・スクリプトを開いてみましょう。

00:34.200 --> 00:40.440
以前のサンプルでは、いくつかのシリアライズされたフィールドがありました。

00:40.440 --> 00:40.980
レベルである。

00:40.980 --> 00:42.320
しかし、ここでは3つある。

00:42.330 --> 00:46.800
このバージョンのミニMVCには3つのビューがあるからだ。

00:46.800 --> 00:51.780
ビューをフレームワークに統合する方法はたくさんありますが、私が持っている良い流れは以下の通りです。

00:51.780 --> 00:57.480
の関連ゲームオブジェクトからの参照をドラッグすることです。

00:57.480 --> 01:01.170
ビュー、プレイヤー、UIをインスペクターウィンドウにドラッグします。

01:01.170 --> 01:06.450
ここでミニクラスを作成し、参照を渡して初期化します。

01:06.450 --> 01:08.250
シーンの階層構造を見てみましょう。

01:08.250 --> 01:14.820
シーン階層では、メインのサンプルスクリプトが3つの参照をシリアライズしています。

01:14.820 --> 01:19.080
シーンにある他の3つのゲームオブジェクトへの参照をドラッグしています。

01:19.080 --> 01:24.810
スクリプトを含むプレイヤービュー、スクリプトを含む入力ビュー、そしてUIビューです。

01:24.810 --> 01:25.650
スクリプト

01:25.650 --> 01:32.460
もっと複雑なプロジェクトになると、UIやその他のビューの要素を以下のように分割したくなることは想像に難くない。

01:32.460 --> 01:33.930
複数のゲームオブジェクト

01:34.760 --> 01:40.460
各オブジェクトは独立して処理することもできるし、別の開発者に割り当てることもできる。

01:40.460 --> 01:43.130
このあたりでコンフリクトや作業の重複が発生する可能性がある。

01:43.160 --> 01:49.610
その理由は、プレイヤーはUIとは異なる役割をゲーム内で担っているという論理的なものであり

01:49.610 --> 01:51.410
入力も全く異なる。

01:51.440 --> 01:53.060
では、コードをもう一度見てみましょう。

01:53.060 --> 01:54.780
ローラーボール・ミニです。

01:54.800 --> 01:57.990
ミニNBCを実装しています。

01:58.010 --> 02:03.860
これまでのサンプルでは、ベースとなるミニMVCクラスをサブクラス化していました。

02:04.540 --> 02:05.320
サブクラスです。

02:05.350 --> 02:10.290
モデル・ビュー・コントローラー・サービスを1つにまとめたい場合に有効です。

02:10.300 --> 02:13.210
シンプルなプロジェクトでは、それぞれ1つずつ持つのが一般的です。

02:13.210 --> 02:14.920
だから、それがデフォルトなんだ。

02:14.920 --> 02:20.350
しかし、ここでは、規模を拡大するにつれて、より詳細な設定が必要になるため、単純に次のように実装します。

02:20.350 --> 02:25.450
インターフェイスを実装することで、プロパティの構造をより柔軟に変更することができます。

02:25.450 --> 02:29.560
他のサンプルと同じようにinitialized in contextを設定します。

02:29.560 --> 02:37.180
モデルをセットアップし、複数のビューをセットアップし、複数のコントローラをセットアップし、サービスをセットアップします。

02:37.180 --> 02:38.500
コンストラクタで設定します。

02:38.500 --> 02:42.460
UIに対応する3つのパラメータを受け取ります。

02:42.460 --> 02:48.010
これらはシリアライズされたフィールドで、使いやすくするためにシーンにドラッグするだけです。

02:49.930 --> 02:55.410
initializeでは、コンテキスト、モデルサービス、コントローラを設定します。

02:55.420 --> 02:59.680
コントローラでは、これまでよりも多くのパラメータを受け取っています。

02:59.680 --> 03:00.640
このように

03:00.640 --> 03:03.310
ミニにはビューとコントローラーが追加されています。

03:03.310 --> 03:06.640
このコンストラクターはいくつかのパラメーターを受け取ります。

03:06.640 --> 03:12.760
ここで初期化する順番は一般的には重要ではありません。

03:12.760 --> 03:20.020
コンストラクタでパラメータを取るので、コントローラを最後に作成し、初期化も最後に行います。

03:20.020 --> 03:21.430
初期化も最後に行う。

03:21.430 --> 03:26.920
事前に渡したパーツはすでに初期化されていることが分かっている。

03:26.920 --> 03:28.000
初期化されている

03:28.000 --> 03:34.960
モデル、コントローラ、ビューの例は以前のサンプルで既に見ました。

03:34.960 --> 03:38.860
そこで、ここではコントローラーを見てみようと思います。

03:38.860 --> 03:42.070
コントローラクラスと以前のサンプルです。

03:42.070 --> 03:45.640
このコントローラーはベースコントローラーを拡張しています。

03:45.640 --> 03:52.540
繰り返しになりますが、1つのモデル、1つのビュー、1つのコントローラ、1つのサービスがある場合、ベースは最も理にかなっています、

03:52.540 --> 03:54.010
これは良いデフォルトです。

03:54.130 --> 03:59.560
しかし、例えば複数のビューを持つなど、より多くの関心事を持ちたい場合はいつでもそうすることができる。

04:00.400 --> 04:02.620
それらを管理するカスタムコントローラーが必要です。

04:02.620 --> 04:08.070
ここでは、以前見たようにAIコントローラーを実装し、その下に実装カスタムを行います。

04:08.080 --> 04:11.290
これまでと同じように、コンテキストの初期化を行います。

04:11.290 --> 04:16.300
コンストラクタの内部では、すべての引数を渡してそれを保存し、initializeの内部では、次のようにしています。

04:16.300 --> 04:21.400
コンテキストで初期化された典型的なセットアップを行い、その後カスタムの詳細に移ります。

04:21.400 --> 04:26.680
モデルからのイベントを監視し、ビューからのイベントを監視し、サービスをキックするように設定します。

04:26.680 --> 04:29.650
UI再起動ボタンが呼び出されたら、いつでもローディングを停止します。

04:29.650 --> 04:31.330
このメソッドも呼ばれる。

04:31.330 --> 04:37.510
この実装は、ミニMVCでないバージョンで見たように、ユーザーに

04:37.510 --> 04:44.680
というダイアログウィンドウが表示される。

04:44.680 --> 04:45.730
サービスがロードされます。

04:45.730 --> 04:49.540
これが呼び出され、入力されたモデル値を設定します。

04:49.540 --> 04:51.730
Vueがイベントをディスパッチします。

04:52.450 --> 04:53.740
このメソッドが呼び出されます。

04:53.740 --> 04:55.120
ここで注目すべきことが2つある。

04:55.120 --> 05:01.300
まず第一に、このモデルには現在ゲームオーバーなのか、それとも現在ゲームオーバーなのかという値が保存されている。

05:01.300 --> 05:01.810
一時停止。

05:01.810 --> 05:07.450
つまり、このコードの何カ所かで、このどちらかに該当する場合、ゲームオーバーになる。

05:07.450 --> 05:08.170
メソッドから抜ける。

05:08.170 --> 05:10.120
つまり、本質的には何も起こっていないのだ。

05:10.120 --> 05:12.190
一時中断かゲームオーバーなら

05:12.190 --> 05:18.100
そして、ごく一般的なパターンが見えてきた。

05:18.100 --> 05:19.720
を聞いている。

05:19.720 --> 05:26.050
ビューがメソッドを呼び出すと、このメソッドが呼び出されます。

05:26.050 --> 05:26.890
コマンドに変換します。

05:27.340 --> 05:34.570
また、ビューイベントのロジックをラジオ局のように放送することもできる。

05:34.570 --> 05:35.920
コマンドという形で。

05:36.100 --> 05:42.160
この時点で、この入力値（ベクトル）をリッスンすることができる。

05:42.160 --> 05:48.070
この入力値は、プレーヤーが矢印キーを使ってどの方向に移動したかを示すベクトルである。

05:48.100 --> 05:49.660
ピックアップとの衝突。

05:49.660 --> 05:54.700
このメソッドが呼ばれます。 ピックアップが回収されたので不可視にし、音を鳴らしてから

05:54.700 --> 05:58.780
0点から1点、2点、3点とカウントアップしていきます。

05:58.780 --> 06:02.020
スコアの最大値が3ならゲームオーバー。

06:02.020 --> 06:07.840
このサンプルを続けていくうちに、いくつかのパターンが見えてきた。

06:10.690 --> 06:16.990
コントローラで、モデルからのイベントブロードキャストを見ている。

06:16.990 --> 06:18.130
スコアが更新されました。

06:18.130 --> 06:21.280
では、それを処理する方法をいくつか考えてみよう。

06:21.280 --> 06:25.360
スコアが更新されることで、さまざまな関係者が関心を持つかもしれない。

06:25.360 --> 06:31.990
例えば、UIは画面に表示される得点の数値を更新したいかもしれない、

06:31.990 --> 06:37.900
特殊効果やオーディオなど、何か他の処理を行いたいかもしれない。

06:37.900 --> 06:39.370
得点が変わるたびに

06:39.370 --> 06:45.670
そのような懸念はすべて、モデルへの参照を取得し、同じイベントにサブスクライブして処理することができます。

06:45.670 --> 06:47.500
ということになる。

06:47.620 --> 06:49.090
それが一つの解決策でしょう。

06:49.090 --> 06:52.480
しかし、このサンプルでは別の解決策をとっている。

06:52.480 --> 06:59.170
モデルチェンジを聞いているのはコントローラだけで、コントローラは次のように変換している。

06:59.170 --> 07:00.940
そのイベントをコマンドに変換する。

07:00.940 --> 07:07.270
コマンドは無線局であり、どのような懸念に対しても放送されるため、これは特に簡単なことである。

07:07.270 --> 07:12.700
このコマンドを聞くには、モデルを参照する必要がない。

07:13.030 --> 07:14.890
それが差別化のポイントだ。

07:14.890 --> 07:18.190
このコマンドを聞くのにモデルへの参照は必要ありません。

07:18.190 --> 07:23.350
そして、この値でモデルが変更されると、同じセットアップでモデルが変更されます。

07:23.350 --> 07:25.900
この値では、また同じ設定が見られます。

07:25.900 --> 07:27.250
コントローラーは以上です。

07:27.250 --> 07:28.540
ビューを見てみましょう。

07:28.570 --> 07:30.940
例えばUIビューです。

07:30.940 --> 07:37.180
さて、前にも説明したように、多くのMVCではモノの動作でなければならないという懸念はありませんが、これは

07:37.180 --> 07:37.870
オプションである。

07:37.870 --> 07:39.370
いつでもできる

07:39.370 --> 07:45.670
そして、これはUI要素であり、Unity UIはmonoビヘイビアでうまく動作するからである。

07:45.670 --> 07:51.700
シーンのゲームオブジェクトの上にビューを置くというアイデアが気に入ったので、ビヘイビアを拡張しました。

07:51.700 --> 07:57.070
再起動ボタンがクリックされたら、いつでもイベントをブロードキャストできるようにカスタムイベントを作成します。

07:57.070 --> 07:57.430
ここで

07:57.430 --> 08:00.130
いつものようにコンテキストの初期化を行う。

08:00.130 --> 08:07.180
UIのテキストフィールドやボタン、ダイアログウィンドウを参照している。

08:07.180 --> 08:08.740
ユーザがrestartを押したとき。

08:08.740 --> 08:14.110
initializeでは、restartボタンへのサブスクライブなど、ごく標準的なことを行っています。

08:14.110 --> 08:14.520
イベント

08:14.530 --> 08:16.930
このパターンは以前にも見たことがある。

08:16.930 --> 08:22.420
ビューはいくつかのコマンド、放送されるラジオ局に興味がある。

08:22.420 --> 08:30.430
UIビューは現在のスコアと最大スコアを表示する。

08:30.430 --> 08:34.810
スコアとステータス・メッセージを表示するので、これらのコマンドをサブスクライブするのは理にかなっている。

08:34.810 --> 08:35.140
ここで

08:35.140 --> 08:39.430
複数の場所からスコアテキストを更新するので、ここで役立つメソッドがある。

08:39.430 --> 08:42.760
得点変更コマンドが発生したら、ここでUIを更新します。

08:42.760 --> 08:47.950
スコアMAXコマンド発生時にはUIを更新し、ステータスコマンド発生時にはUIを更新します、

08:47.950 --> 08:49.120
ステータスを更新します。

08:49.120 --> 08:54.130
コントローラの話をしたときに、様々な構成方法があることを話しました。

08:54.130 --> 08:55.150
コミュニケーション

08:55.150 --> 09:02.230
私がここで選んだ解決策は、UIがモデルを直接参照することなく

09:02.230 --> 09:03.010
を直接リッスンすることです。

09:03.550 --> 09:07.720
その代わりに、これらのコマンドを使って間接的に情報を取得しています。

09:07.720 --> 09:14.410
多くのMVCを使用する上で、イベントをカップリングにするか、コマンドをカップリングにするかを選択することができます。

09:14.410 --> 09:18.700
そして、あなたのニーズによって、それぞれの解決策に長所と短所があるでしょう。

09:18.700 --> 09:19.120
パス

09:19.120 --> 09:24.100
しかし、デモのために言っておくが、もしこのビューがモデルに直接アクセスしたいとしたらどうなるだろうか？

09:24.100 --> 09:29.620
モデルからデータを読み込むためにそうするのは確かにベストプラクティスですが、それは推奨されません。

09:29.620 --> 09:31.750
ビューがモデルに直接書き込むことは推奨されません。

09:31.750 --> 09:37.360
それでは、UIビューのInitializeの構文を見てみましょう。

09:37.360 --> 09:43.270
また、例として、スコアや変更されたコマンドをコメントアウトして、代わりに次のように聞いてみることもできる。

09:43.270 --> 09:44.500
を直接聞くことができる。

09:44.500 --> 09:45.610
その方法を見てみよう。

09:45.610 --> 09:51.280
さて、どのモデルを参照したいのか、そしてコンテキストを使ってどのようにアクセスするのかはわかっています。

09:51.280 --> 09:52.000
とモデルローカルを使えばいい。

09:52.510 --> 09:55.960
ローラーボールのモデルが登録されていれば、それを取得することができます。

09:55.960 --> 10:01.420
そして、気になるイベントを聞き、ここでスコアを出しているのだと思い、その値が出るたびに

10:01.420 --> 10:03.480
リスナーを追加する。

10:03.490 --> 10:07.300
手動でも自動でもいいので、新しいハンドラーを作ります。

10:07.300 --> 10:10.060
適切なメソッドを作ればいい

10:10.060 --> 10:15.550
そして、ローカルスコアを適切な値に設定することで、事前に起こっていたことをそのまま真似したい。

10:15.550 --> 10:16.630
入ってくる値

10:16.630 --> 10:17.980
ドキュメントのため

10:17.980 --> 10:21.010
これらの引数の名前をより意味のあるものに更新することができる。

10:21.010 --> 10:21.910
これで完成だ。

10:21.910 --> 10:28.510
コマンドを使用する代わりに、モデルへの参照を取得し、モデルをサブスクライブする方法を示しました。

10:28.510 --> 10:31.390
イベントにサブスクライブし、そのイベントを直接処理します。

10:31.390 --> 10:37.180
ここで見られる多くの事柄と同様に、モデルの変更からビューへの通信のこのパターンは、次のようなことが起こり得る。

10:38.890 --> 10:43.350
ここで紹介したのは、コマンドを使う方法と使わない方法です。

10:43.360 --> 10:49.600
先ほど、デモのためにピックアップを別のフォルダに入れたと言ったが、これはそのためだ。

10:49.600 --> 10:52.120
を別フォルダにしました。

10:52.120 --> 10:59.740
プロジェクトでは、構造的にミニの中にあるものと、ミニの外にあるものを使い分けたい場合があります。

10:59.740 --> 11:00.340
ミニ

11:00.340 --> 11:02.860
これは外側にあるものの例です。

11:02.860 --> 11:07.510
これはモデルビューコントローラーサービスの一部ではなく、ミニ自体の一部でもありません。

11:07.510 --> 11:09.790
別の構造にすればよかったのに

11:09.790 --> 11:13.720
しかし、ここではデモのために、外に座っているところを映しています。

11:13.720 --> 11:17.770
この黄色いキューブには、それぞれこのピックアップ・コンポーネントが付いています。

11:18.070 --> 11:22.690
その中身を見てみましょう。ピックアップコンポーネントのクラスでは、モデルビヘイビアを継承しています。

11:22.690 --> 11:23.440
これは理にかなっている。

11:23.440 --> 11:28.290
このように "キューブ "をシーンに配置し、回転などの動作をさせたいのです。

11:28.300 --> 11:34.270
回転する立方体である必要がある、

11:34.300 --> 11:40.480
拾われること、そして拾われたときにその結果を処理することである。

11:40.480 --> 11:46.000
ここで、いくつかのローカルフィールドを復元し、このピックアップがゲームが一時停止しているのか、それともゲームオーバーなのかを知ることができるようにする。

11:52.840 --> 12:00.580
このような高レベルのゲーム状態は、プレイヤーや敵、ピックアップなどの小さなパーツに使用されています。

12:00.580 --> 12:02.140
よくあることです。

12:02.140 --> 12:05.950
だからこのデモでは、その情報をどう受け渡すかを探っていたんだ。

12:05.950 --> 12:12.880
でも、これからお見せするのは、実験的なアイデアです。

12:12.880 --> 12:15.610
何が可能なのか、あなたの考えを広げる手助けをするものです。

12:15.610 --> 12:19.930
これは必ずしもベストな方法ではないし、最もシンプルな道でもない。

12:19.930 --> 12:21.580
いささかクレイジーなアイデアだ。

12:21.580 --> 12:22.450
見てみよう。

12:22.450 --> 12:29.710
このピックアップはシステムからやや外れたところで考えているため、選択したビューでもなければ、別のビューでもない。

12:29.710 --> 12:30.340
気になるところだ。

12:30.340 --> 12:34.030
どうすればビューの中からデータにアクセスできるのでしょうか？

12:34.030 --> 12:40.300
シーンがウェイクアップし、このオブジェクトがウェイクアップしたら、ミニへのブリッジを作成します。

12:40.300 --> 12:42.070
これが実験的解決策です。

12:42.070 --> 12:47.380
これでコンテキストを確認し、コンテキストモデルのロケーターを確認した。

12:47.380 --> 12:51.660
モデルロケーターはモデルを登録し、それを検索することができます。

12:51.670 --> 12:53.620
このサンプルでは以前にも見たことがあります。

12:53.620 --> 12:58.810
コンテキストロケーターはフレームワークの中ではここ以外では使われていない。

12:58.810 --> 13:04.690
これはシングルトンで、どんなコンテキストでもコンテキストロケータに追加することができる。

13:04.690 --> 13:08.620
このスコープを含め、どのスコープでもコンテキストを取り出すことができる。

13:08.620 --> 13:15.430
だから、コンテキストが追加され、そのコンテキストにモデルが追加された場合は、いつでもチェックする。

13:16.930 --> 13:19.450
そして、その変更をここで購読する。

13:19.450 --> 13:24.610
イベントハンドラでは、気になる値のローカルバージョンを保存するだけです。

13:24.610 --> 13:32.200
そして、ゲームが終わるか終わらないか、ゲームが一時停止されるか一時停止されないかに関わらず、各ピックアップがそのイベントをリッスンする。

13:32.200 --> 13:33.560
そして適切に対応する。

13:33.580 --> 13:39.940
この具体的な使用例では、私はこのような処理はしませんが、サンプルの1つではこのような処理が必要でした。

13:39.940 --> 13:45.070
非ミニワールドとミニワールドの橋渡しをする方法をお見せしましょう。

13:45.070 --> 13:47.020
これがその例だ。

13:47.020 --> 13:53.530
実際の使用例としては、現在ミニワールドに対応していないゲームを持つことにした場合などが考えられます。

13:53.530 --> 13:59.080
ハイブリッドソリューションにミニを導入したい場合、ここで紹介したテクニックを使うことができる。

13:59.080 --> 14:03.010
を使えば、まだミニになっていない部分を気にすることができる。

14:03.010 --> 14:05.200
|にできるようになります。

14:05.200 --> 14:09.400
だから、この実験的な部分も含めて、何かアイデアがひらめけばいいなと思っています。

14:09.400 --> 14:12.490
これで、このサンプルに必要なコードをすべて見ることができました。

14:12.490 --> 14:13.360
以上です。
