WEBVTT

00:00.090 --> 00:01.410
ビューを設定しよう。

00:01.920 --> 00:05.040
新しいゲームオブジェクトを作成し、シーン階層に配置します。

00:05.400 --> 00:09.360
Viewがunity UIを使うことが分かっているので、そうします。

00:09.540 --> 00:13.850
ユニティUIはモノのビヘイビアを使うことでいい感じになる。

00:13.860 --> 00:16.080
まずはunity canvasを作ります。

00:16.080 --> 00:20.730
シーンヒエラルキーで右クリックして、キャンバスの作成を選択します。

00:20.730 --> 00:24.330
キャンバスには入力フィールドとボタンが必要です。

00:24.780 --> 00:26.310
それで全部だ。

00:27.320 --> 00:28.340
キャンバスの中に。

00:28.340 --> 00:33.680
ゲームビューの大部分を占める灰色の四角が浮遊するパネルを作りました。

00:33.710 --> 00:41.270
そして、3つの入力欄と2つのボタンを追加し、A、Bの結果を入力できるようにしました、

00:41.570 --> 00:45.470
そして、追加、クリア、リセットのボタンを追加した。

00:45.500 --> 00:47.930
現在、これらのUI要素はすべて同じ位置にあります。

00:47.930 --> 00:49.190
画面の中央に配置されています。

00:49.640 --> 00:51.020
それでは修正します。

00:51.880 --> 00:52.060
これで

00:52.060 --> 00:56.410
UIエレメントを配置し、シーン階層に名前を付けました。

00:56.410 --> 01:00.760
A、B、結果の入力欄があるわけですね。

01:01.460 --> 01:04.730
追加とリセットのボタンもあります。

01:04.730 --> 01:06.990
この構造のベースはキャンバスです。

01:07.010 --> 01:13.210
canvasの名前をビューの名前に合わせて変更し、カスタムクラスを追加します。

01:13.220 --> 01:18.560
ここでは、電卓ビューのクラスを追加して、電卓のコードを設定します。

01:18.560 --> 01:20.280
ビューはUnity UIを使っています。

01:20.300 --> 01:23.180
monoの動作を拡張しました。

01:23.180 --> 01:27.170
アイビューを実装し、足りないメンバーを実装します。

01:27.170 --> 01:28.510
デフォルトのものを使います。

01:28.520 --> 01:30.020
初期化を行います。

01:30.030 --> 01:31.950
これで初期化は完了です。

01:31.970 --> 01:38.330
次に、必要なUIフィールドをすべてシリアライズして、それぞれに必要なイベントを観察する。

01:38.330 --> 01:43.610
このフィールドでは、必要なUI要素ごとにシリアライズされたフィールドを作成しました。

01:43.610 --> 01:46.040
initializeではいくつかの重要なイベントをリスニングしています。

01:46.040 --> 01:52.880
ユーザーがAかBの入力フィールドを編集している時はいつでも、ここで何かをします。

01:52.880 --> 01:57.310
をクリックしたりリセットをクリックした場合の結果を実装します。

01:57.320 --> 02:00.160
シーン階層に戻り、ビューの配線をしてみましょう。

02:00.170 --> 02:05.270
電卓ビューで、シリアライズされたフィールドをUIエレメントに配線します。

02:05.270 --> 02:07.730
まずはAの入力フィールドから。

02:09.110 --> 02:12.830
結果を入力フィールドにします。

02:14.280 --> 02:15.570
ボタンを追加します。

02:16.840 --> 02:17.980
そしてリセットボタン。

02:17.980 --> 02:20.720
これでシーン階層はほぼ完成。

02:20.740 --> 02:26.020
もう一つ必要なのは、電卓ビューをミニ本体に渡すことだ。

02:26.020 --> 02:30.280
サンプルファイルでは、フィールドをシリアライズして電卓ミニに渡しています。

02:30.280 --> 02:33.610
フィールドを作成し、コンストラクタに渡します。

02:33.610 --> 02:34.720
クラスを更新しましょう。

02:34.720 --> 02:37.270
コンストラクタにフィールドが渡されます。

02:37.270 --> 02:42.160
以前はコンストラクタがなかったので、ここでコンストラクタを作成し、電卓ビューを受け入れて保存しましょう。

02:42.160 --> 02:44.470
電卓ビューをキュー階層に戻します。

02:44.470 --> 02:49.390
電卓ビューから新しい直列化されたフィールドに参照をドラッグします。

02:49.390 --> 02:52.810
これで、シーンに必要なほとんどのものがセットアップされました。

02:52.810 --> 02:55.030
シーンを保存してコードに戻ります。

02:55.030 --> 02:58.090
この時点で、プロジェクトはかなり整いました。

02:58.090 --> 03:05.920
ミニクラス、モデル、ビュー、コントローラの実装は一通りできています。

03:05.920 --> 03:11.140
まだ完成ではありませんが、シーンのセットアップも完了しました。

03:11.140 --> 03:12.460
電卓ミニクラス

03:12.460 --> 03:19.030
initializeでコンテキストを設定し、モデルを作成しました。

03:19.150 --> 03:23.500
ここではビューで何かをしているわけではありませんが、かなりうまく配線できていることがわかります。

03:23.500 --> 03:28.840
コントローラは実装が必要で、初期化も行っています。

03:28.840 --> 03:31.720
ユースケースに戻り、ブレインストーミングをしましょう。

03:31.720 --> 03:39.190
つまり、2つのint型の値を受け取り、足し算をして、その結果を表示したかったということだ。

03:39.190 --> 03:40.570
ここまでが進捗状況です。

03:40.570 --> 03:45.340
ビューの要件はここで設定できましたが、モデルやコントローラがありません。

03:45.340 --> 03:47.980
どれを次にするかは自由に選べる。

03:47.980 --> 03:52.780
モデルの実装がもっと簡単になりそうなので、最後に

03:52.780 --> 03:55.840
モデルの実装がより簡単になりそうな気がするので、モデルの実装を終えて、コントローラのコーディングに取りかかろう。

03:55.840 --> 03:59.680
モデルにはintを格納します。

03:59.680 --> 04:04.600
これまでのサンプルでは、observableクラスを使ってきました。

04:04.600 --> 04:09.940
observableクラスは、INTを保存する機能だけでなく、保存された値の変更をリスニングする機能も備えています。

04:09.940 --> 04:11.140
では、それを使ってみましょう。

04:11.140 --> 04:15.130
a,b,結果のプロパティとフィールドを作成します。

04:15.130 --> 04:20.950
プロジェクトXでは、publicなプロパティの下にprivateな値を置くのが私のやり方だ。

04:20.950 --> 04:21.850
それはオプションです。

04:21.850 --> 04:24.040
その代わりにパブリックフィールドを持つこともできる。

04:24.040 --> 04:29.110
今まで見てきた他の例と同じように、モデルのinitializeを使ってデフォルト値を設定します。

04:29.110 --> 04:31.360
デフォルト値がどのようなものであるかによって異なります。

04:31.390 --> 04:34.150
これは必要ないかもしれないが、素晴らしい練習方法だと思う。

04:34.150 --> 04:39.910
電卓モデルはベースモデルを拡張するものであり、ベースモデルはすでに初期化処理をしている。

04:39.910 --> 04:45.160
だから、一般的なオブジェクト指向プログラミングと同じように、親メソッドをオーバーライドすることができる。

04:45.160 --> 04:49.390
ベースメソッドを呼び出して、ベースとなる機能を取得し、デフォルトを設定します。

04:49.390 --> 04:51.580
これでコントローラーは完成です。

04:51.580 --> 04:54.520
コントローラーの実装はパズルの最後のピースです。

04:54.520 --> 04:56.950
ビューのセットアップとモデルのセットアップを行いました。

04:56.950 --> 04:59.920
あとはコントローラーが全てをまとめる接着剤になる必要があります。

04:59.920 --> 05:04.360
まず、コンストラクタを作成し、すべての関心事を取り込む。

05:04.360 --> 05:09.190
この場合、コントローラーは、電卓モデルである他の関心事を扱うことになります。

05:09.190 --> 05:10.060
と電卓ビューです。

05:10.060 --> 05:15.400
これらをフィールドとして保存し、initializeを更新して、以下のようなごく一般的なステップを実行します。

05:15.400 --> 05:17.680
初期化され、コンテキストが保存されます。

05:17.680 --> 05:20.530
では、コントローラで必要なことは何でしょうか？

05:20.740 --> 05:25.990
まず、モデルへの参照を得たので、そのモデルへの変更を監視したい。

05:25.990 --> 05:30.970
そして、電卓ビューを参照することで、そのビューの重要な部分を観察したい。

05:30.970 --> 05:32.290
のイベントを観察したい。

05:32.290 --> 05:33.490
では、設定してみよう。

05:34.200 --> 05:40.770
initializeの中で、resetイベントとADDイベントをリスニングする。

05:40.770 --> 05:41.640
ビューから

05:41.940 --> 05:43.440
では、これらのイベントを作成しましょう。

05:44.410 --> 05:47.410
The Viewのトップに、2つのイベントを作成します。

05:47.440 --> 05:50.470
どちらも情報を送信する必要はない。

05:50.740 --> 05:53.230
だから、基本的なユニティー・イベントを使えばいいんだ。

05:53.970 --> 06:00.120
ここで、on addとon resetのイベント以下を同じクラスで作ってみた。

06:00.120 --> 06:06.360
UIをリッスンし、ボタンのひとつがクリックされたことを捉えたら、このカスタムイベントを送信します。

06:07.990 --> 06:14.650
余談ですが、コントローラーはビューを参照しており、ビューの要素は

06:14.650 --> 06:16.750
publicである。

06:16.960 --> 06:22.810
代わりに、コントローラが直接UIイベントをリッスンするようにすればいい。

06:22.810 --> 06:24.330
ステップでカスタムイベントを使用します。

06:24.340 --> 06:29.620
ここで示しているのは、より分離されたアプローチであり、どちらがうまくいくかプロジェクトで決めることができます。

06:29.620 --> 06:30.220
どちらが良いかはプロジェクトで決めてください。

06:30.220 --> 06:35.200
コントローラーの中で、この2つのイベントを配線し、それぞれにハンドラーを設定した。

06:35.380 --> 06:39.670
では、それぞれの結果をどうしたいのか、少し考えてみましょう。

06:39.940 --> 06:46.030


06:46.030 --> 06:48.490
Bフィールドから、そして結果フィールドから。

06:48.490 --> 06:50.260
そして、何を追加したいのか？

06:50.260 --> 06:56.080
AフィールドとBフィールドを足したものを結果フィールドにしたいんだ。

06:56.080 --> 06:58.720
多くのMVCでは、柔軟性があります。

06:58.720 --> 07:01.120
では、どのような方法があるのか、いくつか話してみよう。

07:01.120 --> 07:07.210
おそらく最も直接的な方法は、コントローラーがビューで直接フィールドを変更することでしょう。

07:07.240 --> 07:08.560
それでは、どのように見えるか見てみましょう。

07:08.560 --> 07:14.800
最も直接的なアプローチであるリセットから始めて、ビューに手を伸ばし、フィールドを設定します。

07:14.800 --> 07:16.900
UIの値を空文字列に戻す。

07:16.900 --> 07:22.630
そして、on ADDでそれらの値を取得し、足し合わせてビューを直接更新する。

07:22.630 --> 07:24.430
シーンを実行して、この動作を見てみよう。

07:24.430 --> 07:26.290
実行中のシーンです。

07:26.290 --> 07:28.960
いくつかのサンプル値を追加し、リセットをクリックします。

07:28.960 --> 07:30.610
ちゃんとリセットされたようです。

07:30.610 --> 07:33.550
もう一度値を追加して、追加ボタンをクリックします。

07:37.620 --> 07:38.330
いい感じだ。

07:38.340 --> 07:41.220
これで構成を考えてみましょう。

07:41.220 --> 07:47.520
この時点で、コントローラーが直接ビューにアクセスするのは

07:47.520 --> 07:48.860
ここでどのように振る舞うか。

07:48.870 --> 07:49.880
大丈夫です。

07:49.890 --> 07:55.140
コントローラが参照し、表示し、コントローラが直接更新するのは構わない。

07:55.140 --> 07:56.940
ビューを直接更新する。

07:56.970 --> 07:58.620
モデルをバイパスする

07:58.620 --> 08:03.480
基本的には、モデルのデータをビューに直接保存しています。

08:03.480 --> 08:09.510
そして、根本的な観点からは、MVCの懸念事項の分離から抜け出している。

08:09.510 --> 08:14.880
これを繰り返して、もう少し健全な原則をコードに反映させましょう。
