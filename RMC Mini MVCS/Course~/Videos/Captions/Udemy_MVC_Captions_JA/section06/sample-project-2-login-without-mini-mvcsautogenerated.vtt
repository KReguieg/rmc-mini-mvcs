WEBVTT

00:03.200 --> 00:04.700
ここはUnityの中だ。

00:04.700 --> 00:10.490
ミニVCフレームワークをインストールし、サンプルをインポートしました。

00:10.520 --> 00:13.960
以下は、多数あるバージョンのファイル構成です。

00:13.970 --> 00:19.660
サービスレイヤーの呼び出しをシミュレートするために読み込むテキストファイルを含むリソースがあります。

00:19.670 --> 00:23.750
そしてランタイムスクリプトがあります。

00:23.750 --> 00:29.210
サンプルではまだMVCsのコードの構造を見ていません。

00:29.210 --> 00:34.370
さて、一番下から、ゲームオブジェクトにアタッチされたサンプルファイルそのものを

00:34.370 --> 00:34.880
シーンにあります。

00:34.880 --> 00:37.010
そして、ミニ・クラスにログインします。

00:37.010 --> 00:40.880
これがMVCの世界の最上位構造です。

00:40.880 --> 00:47.900
そして、典型的な慣例に従って、モデル・ビュー・コントローラーとサービスのそれぞれにフォルダを作ります。

00:47.900 --> 00:50.750
ビューの中にはログインビューというクラスが一つあります。

00:50.750 --> 00:54.140
サービスの内部にはログインサービスがあります。

00:54.140 --> 00:55.250
モデルの内部です。

00:55.250 --> 01:02.210
の中にログインのためのメインモデルとユーザーデータのクラスがあります。

01:02.210 --> 01:03.200
controllerフォルダにあります。

01:03.200 --> 01:07.070
プロジェクトのメインコントローラであるログインコントローラがあります。

01:07.160 --> 01:12.050
サブフォルダにはプロジェクトのコマンドを保存しておくのが適切です。

01:12.050 --> 01:16.970
コマンドについては、以前のコードでまだ見ていないので、もう少し詳しく説明します。

01:16.970 --> 01:17.770
セッション

01:17.780 --> 01:22.940
これは比較的単純な例ですが、プロダクション・プロジェクトでは次のようにするのが妥当でしょう。

01:22.940 --> 01:29.330
同じフォルダ構造に従えば、それぞれのフォルダに複数のモデルが配置されることになります、

01:29.330 --> 01:36.680
複数のビューとサービス、たくさんのコントローラ、そしておそらく本当に強固な

01:36.680 --> 01:37.490
コマンドでいっぱいです。

01:37.490 --> 01:44.330
コマンド・マネージャーはラジオ局のようなもので、あらゆる関係者に向けて放送することができる。

01:44.330 --> 01:50.510
この場合、ログインやログのような高レベルのメッセージが適切です。

01:50.510 --> 01:51.920
画面を消す

01:51.920 --> 01:55.730
このような機能があれば、それらは個別のコマンドとしてここに置かれるでしょう。

01:55.730 --> 01:58.340
では、ミニ・サンプルを実行します。

01:58.340 --> 02:01.070
ヒントが示すように、パスワードが提案されています。

02:01.070 --> 02:03.410
パスワードはこれだけです。

02:03.440 --> 02:05.570
ローカルファイルと照合しています。

02:05.570 --> 02:09.170
正しいデータがあります。

02:09.170 --> 02:14.090
サービス・レイヤーがローカルのテキストファイルを読み込んでいる。

02:14.090 --> 02:17.990
UIに入力された内容がテキストファイルの内容と一致するかどうかを確認する。

02:17.990 --> 02:23.960
複雑なバックエンドとのやり取りを簡略化したものだ。

02:25.330 --> 02:28.260
まずは、ハイレベルな例からコードを掘り下げてみよう。

02:28.270 --> 02:32.800
これがその例で、シーンのゲームオブジェクトの上にあるビヘイビアです。

02:32.830 --> 02:37.570
多くのMVCでは、ビヘイビアを尊重する必要はありません。

02:37.570 --> 02:45.070
しかし、この例では、おそらくあなたの仕事でも一般的であるように、ビューbの金額を持っています。

02:45.070 --> 02:45.880
行動の

02:46.000 --> 02:52.840
だから、それをゲームに取り入れる簡単な方法は、ゲームの行動量として表示させることだ。

02:52.840 --> 02:58.240
オブジェクトのビヘイビアとして配置し、シリアライズされた参照としてドラッグし、それを

02:58.240 --> 03:00.260
このようにミニコンストラクタに渡すことができます。

03:00.280 --> 03:03.310
どのように配線されているのか、シーンを見てみましょう。

03:03.310 --> 03:05.950
このシーンではViewが選択されています。

03:05.950 --> 03:11.360
インスペクタ・ウィンドウを見ると、このゲーム・オブジェクトの上にログイン・ビュー・スクリプトがあるのがわかります。

03:11.380 --> 03:17.110
例題を選択した状態で、シリアライズされたフィールドが参照を待っているのがわかります。

03:17.110 --> 03:18.270
への参照を待っている。

03:18.280 --> 03:22.300
これがシーン内で必要な唯一の配線です。

03:22.570 --> 03:28.420
別の方法もありますが、ビューのようなモノビヘイビアを持つのはとても馴染みがあります。

03:28.420 --> 03:32.230
のようなmonoビヘイビアを持つことはとてもよく知られています。

03:32.230 --> 03:38.080
この例に戻って、クラスを作成し、ビューを渡すと、次のようになります。

03:38.080 --> 03:39.070
を初期化します。

03:39.070 --> 03:40.510
このレベルで終わりです。

03:40.510 --> 03:42.340
次のクラスを見てみましょう。

03:42.820 --> 03:45.100
ここはログインミニのクラスです。

03:45.490 --> 03:51.490
このサンプルは、コンテキスト、モデル、ビューコントローラー、サービスという、ごくありふれたものです。

03:51.490 --> 03:54.970
を1つずつ使っているので、ここで基底クラスを利用することができる。

03:54.970 --> 04:02.830
多くのNPCはこのクラスを拡張し、コンストラクタの内部で必要な懸念事項ごとに強い型を渡します。

04:02.830 --> 04:07.210
私はビューを渡すだけで、initializeの中で大部分を処理します。

04:07.210 --> 04:10.970
ここで、コンテキスト、モデル、ビュー、コントローラを作成します。

04:10.990 --> 04:15.340
コントローラは複数の引数を取る唯一のコンストラクタであることに注意してください。

04:15.340 --> 04:21.400
このことは、コントローラーが構造上、より重要であることを示すヒントになる。

04:21.400 --> 04:23.880
そして最後に、それぞれのパーツを初期化します。

04:23.890 --> 04:25.360
これでこのクラスは終わりです。

04:25.360 --> 04:30.940
さて、先ほどのサンプルコードでは、モデル・ビュー・コントローラーとサービスのそれぞれについて説明しました。

04:30.940 --> 04:34.510
ここでは簡潔にするために、サービスレイヤーは非常に似ています。

04:34.510 --> 04:38.830
よろしければコードとモデルもご覧ください。

04:38.830 --> 04:42.670
ここでのユニークな点は、ビューとコントローラーです。

04:42.670 --> 04:43.900
それぞれを見てみましょう。

04:44.200 --> 04:45.460
これがログインビューです。

04:45.460 --> 04:48.790
これはシーン内のゲームオブジェクトの上に置かれています。

04:48.790 --> 04:54.010
このデモのように、その場で作成されるわけではありません。

04:54.010 --> 04:58.720
ここで下にスクロールして、クラスのハイレベルな部分を見てみよう。

04:58.720 --> 04:59.740
一行ずつ

05:32.460 --> 05:34.990
まず、いくつかのカスタムユニティーイベントがあります。

05:35.010 --> 05:38.960
このミニMVCに特化したフローというわけではありません。

05:38.970 --> 05:40.580
一般的な流れです。

05:40.590 --> 05:46.800
Unity内でUnityイベントを送りたいとき、パラメータにlong型を送りたいときはいつでも、

05:46.800 --> 05:52.800
このように常にサブクラス化することで、クラスの詳細を見ることはあまり重要ではありません。

05:52.800 --> 05:55.140
なぜなら実装がないからだ。

05:55.140 --> 06:01.610
このクラスには名前を付け、その中にどのようなサブタイプを持つかを宣言するだけです。

06:01.620 --> 06:08.490
例えば、Unityのログインイベントは、呼び出されるたびにユーザーデータを受け取り、その情報を渡します。

06:08.490 --> 06:08.970
のようになります。

06:08.970 --> 06:12.340
Monoのビヘイビアを拡張したビューはこれが初めてだ。

06:12.360 --> 06:17.910
多くのMVCでは、マウントされたビヘイビアを使うことは完全にオプションであることを覚えておいてください。

06:17.910 --> 06:24.270
のためにmonoビヘイビアを拡張するでしょう。

06:24.270 --> 06:25.190
ビューを拡張することになる。

06:25.200 --> 06:30.600
それは、ビューの役割はユーザー入力とユーザーインターフェイスの要素を扱うことだからです。

06:30.600 --> 06:34.540
そしてunityでは、モノビヘイビアが関与する方が理にかなっているのです。

06:34.560 --> 06:38.040
次にプロパティとフィールドを宣言します。

06:38.430 --> 06:44.610
これらのUI要素は、前に見たミニMVCでないバージョンと同じです。

06:44.640 --> 06:48.330
どのサンプルも同じように見え、同じように動作するということです。

06:48.330 --> 06:53.040
前節のinitializeでおなじみのコードがたくさん出てきますね。

06:53.040 --> 06:55.080
いくつか面白いことが起きています。

06:55.080 --> 07:02.340
まず、UIボタンのブロックがあり、unityイベントを購読している。

07:02.340 --> 07:03.960
ミニMVCでないバージョン。

07:03.960 --> 07:05.100
これはごく普通のことだ。

07:05.100 --> 07:09.630
UnityのUIから返事が欲しいときは、unityイベントを購読する。

07:09.630 --> 07:12.890
しかし、この2番目のセクションはこのフレームワーク独自のものだ。

07:12.900 --> 07:17.520
ここでは、どのような関心やアクセスからも利用可能なコンテキストを使用する。

07:17.520 --> 07:18.640
コマンドマネージャー

07:18.660 --> 07:24.450
このサンプルでは、コマンドマネージャーについてもう少し詳しく説明します。

07:24.540 --> 07:29.910
コマンド・マネージャーはコンテキストの上に置かれ、そのコンテキストはすべての関係者に回される。

07:29.910 --> 07:37.290
コマンドマネージャーでできることの一つは、様々な通知を受信するためのサブスクライブだ。

07:37.290 --> 07:38.910
コマンドとして送られてくる

07:39.390 --> 07:41.310
もう一つは、それらを呼び出すことができるということです。

07:41.310 --> 07:48.240
しかし、これらのコマンドを追加したり、呼び出したりする際に、誰が聞いているのかを知る必要はない。

07:48.240 --> 07:54.000
コマンド・マネージャーは2つのレイヤーの間に位置する仲介者である。

07:54.000 --> 07:55.500
オブザーバーと送り手。

07:55.710 --> 08:01.560
だから、ラジオ局のようなメッセージをやみくもに送ることができる。

08:01.560 --> 08:03.480
空に向かって放送しているようなものだ。

08:03.480 --> 08:08.910
誰かがその周波数やコマンドを受信すると

08:08.910 --> 08:09.690
メッセージ

08:09.690 --> 08:15.450
そして、このクラスのコードラインの下に行くにつれて見えてくることがある。

08:15.450 --> 08:15.900
ユニティ

08:15.900 --> 08:20.880
UIがクリックされたことをコマンドに変換します。

08:20.880 --> 08:22.410
どうなるかは見てのお楽しみ。

08:22.440 --> 08:27.510
前の例と同じように、ユーザーがテキストフィールドに入力したり、それを消去したりする時はいつでも、ただ

08:27.510 --> 08:29.410
はログインボタンを更新します。

08:29.430 --> 08:33.960
このアイデアは、ユーザーの投稿が正しい可能性があるかどうかを検証するというものです。

08:33.960 --> 08:38.760
フィールドが空か、空でないかをチェックするだけだ。

08:38.760 --> 08:43.920
ログインボタンがクリックされるたびに、それをビューイベントに変換し、ディスパッチします。

08:43.920 --> 08:47.520
このスコープでは、誰が聞いているのか、誰が聞いているのかはわかりません。

08:47.520 --> 08:51.360
しかし、次のセクションに入れば、誰が加入者なのかがわかるだろう。

08:51.900 --> 08:52.500
同じだ。

08:52.500 --> 08:55.290
ログアウトボタンがクリックされたら、そのメッセージを送信します。

08:55.290 --> 08:59.790
つまり、ローカルユニティのイベントをカスタムビューのイベントに変換しているわけだ。

09:00.640 --> 09:02.560
一般的なベストプラクティスの一環として。

09:02.560 --> 09:07.210
destroyの内部でsubscribeしたものは、ここでunsubscribeする。

09:07.510 --> 09:12.820
さて、このクラスの上の方では、ログアウトコマンドを受信するようにサブスクライブしています。

09:12.820 --> 09:20.110
ログアウトコマンドが送信されたら、それを捕捉してフィールドを消去し、次のようにする。

09:20.110 --> 09:22.360
ボタンをクリックします。

09:22.630 --> 09:25.750
また、ビューはログイン投稿をリスニングしています。

09:25.960 --> 09:31.660
そのたびに、UIは投稿の準備をし、ビューもまた投稿を待ち受けます。

09:31.660 --> 09:32.950
ログインが完了する。

09:33.250 --> 09:38.440
このクラスで一番大きなメソッドだと思いますが、ミニ以外のメソッドとまったく同じように動作します。

09:38.440 --> 09:39.040
バージョン

09:39.040 --> 09:42.940
だから、そちらをご覧になって、私がどのように詳細を説明したかをご覧になってください。

09:42.940 --> 09:44.650
本当に同じことをしている

09:45.130 --> 09:48.430
例として、ここに少し余分なコードを書いておきます。

09:48.430 --> 09:55.060
ハイライトされている部分は、各コマンドに関連するデータが含まれていることを示している。

09:55.390 --> 10:01.870
ログインが完了したら、ユーザーデータをUIに表示することができます、

10:02.350 --> 10:10.330
ビューを含むどのスコープからでも、このアプローチの完全な代替案を示すことができます。

10:10.330 --> 10:14.350
このモデルを持って来てくれ。

10:14.350 --> 10:20.950
そのモデルが存在するのであれば、そのモデルを取得し、デバッグのログアウトを含め、好きなことをすることができます。

10:20.950 --> 10:21.700
その値をデバッグすることもできる。

10:21.700 --> 10:25.240
これも柔軟性の一例だ。

10:25.240 --> 10:31.450
ここでの慣例では、コマンドと一緒にメッセージを送るのがベストだろう。

10:31.450 --> 10:37.480
つまり、カップリングが少なくなり、この懸念が他の懸念の構造について知ることが少なくなる。

10:37.480 --> 10:43.510
このハイライトされたコードは、ビューがどのモデルのどのデータを見るべきかを知っていることを示唆している、

10:43.510 --> 10:45.790
これは行き過ぎと言えるかもしれない。

10:45.790 --> 10:52.900
しかし、ユースケースによっては、またUIの構造によっては、それは完璧なものになるかもしれない。

10:52.900 --> 10:57.730
しかし、ユースケースやUIの構造によっては、そのデータをレンダリングするために特定のモデルを使用することは非常に理にかなっています。

10:57.730 --> 11:00.820
ビューがモデルのデータに直接影響を与えることは避けたい。

11:00.820 --> 11:02.470
それは悪い習慣だ。

11:02.470 --> 11:04.180
これでViewクラスは終わりです。

11:04.180 --> 11:09.010
さて、次に進む前に、コマンドマネージャーとコマンドについて少し調べてみたいと思います。

11:09.010 --> 11:12.550
というのも、以前のサンプルコードでは、この構造を見ていなかったからだ。

11:12.850 --> 11:19.450
上のinitializeでコマンドリスナーを追加していることを思い出してほしい。

11:19.450 --> 11:22.060
では、具体的に何をするのか見てみよう。

11:22.060 --> 11:24.540
まずは復習のためにコンテキストを見ていきます。

11:24.550 --> 11:29.800
コンテキストクラスが重要なのは、モデルロケーターとコマンドマネージャーを持っているからだ。

11:30.100 --> 11:32.830
この議論に関係するのはコマンド・マネージャーだ。

11:32.830 --> 11:37.450
コマンド・マネージャーは、登録されている様々なコマンドのリストと考えることができる。

11:37.450 --> 11:44.530
そのため、APIによってこれらのコマンドのリスニングを追加したり、任意のコマンドを呼び出したりして柔軟に対応することができる。

11:44.530 --> 11:49.960
AIコマンドでなければならないが、Iコマンドはほとんどマーカーインターフェイスであることに注意してほしい。

11:49.960 --> 11:54.070
このようなニーズに応じて、実装を保証するものではありません。

11:54.070 --> 12:01.510
実行機能と取り消し機能を必要とする別の実装が必要かもしれません。

12:01.510 --> 12:08.470
しかし、このサンプルのような基本的な使用例では、ただ単にダムオブジェクトとして渡しているだけだ。

12:08.470 --> 12:09.400
パラメータ

12:09.400 --> 12:14.470
ログインの例を見てみよう。

12:14.830 --> 12:16.270
構造を見てみましょう。

12:16.270 --> 12:22.360
提出されたログインのコマンドはIコマンドのインターフェイスを実装していることがわかる。

12:22.360 --> 12:25.660
のインターフェイスを実装していることがわかる。

12:25.660 --> 12:31.060
つまり、コンストラクタがあり、そのコンストラクタがこのタイプの操作に必要なデータを受け取るということだ。

12:31.060 --> 12:32.730
そしてそれをローカルに保持する。

12:32.740 --> 12:34.780
そして、そのデータがどこで呼び出されるのかを見てみよう。

12:34.780 --> 12:39.790
しかし、このコマンドをリッスンしているのはビューであり、ログイン時に送信されるコマンドであることを忘れてはならない。

12:39.790 --> 12:45.610
UIが更新され、渡されたユーザーデータが使われます。

12:45.610 --> 12:47.200
UIを更新するのに役立つ。

12:47.230 --> 12:48.910
ログイン画面は以上です。

12:48.910 --> 12:52.780
ログインのミニクラスに戻って、ビューを見てみましょう。

12:52.780 --> 12:54.910
最後にコントローラを見てみましょう。

12:54.910 --> 12:56.380
これがパズルの最後のピースです。

12:56.380 --> 13:02.680
ログインコントローラはベースコントローラを継承しています。

13:02.680 --> 13:04.030
ベースはオプションです。

13:04.030 --> 13:08.620
ここでは、以前のコードサンプルでお話ししたような自由な機能を手に入れることができます。

13:08.620 --> 13:09.690
をスキップします。

13:09.700 --> 13:13.030
initializeの内部では、コントローラがリファレンスを持っています。

13:13.030 --> 13:15.390
次に他の主要な問題です。

13:15.400 --> 13:21.790
ここで注目すべきは、私たちにとって興味深いイベントをリッスンするように配線していることです。

13:21.790 --> 13:26.020
モデル、ビュー、サービスをリッスンします。

13:26.350 --> 13:28.870
コントローラーが接着剤であることがわかります。

13:28.870 --> 13:34.330
異なるレイヤーの間に位置する中間的な存在であり、レイヤーのイベントをリッスンし、レイヤーのイベントを処理する。

13:34.330 --> 13:37.150
13:37.150 --> 13:37.150 --> 13:37.150 --> 13:37.150 --> 13:37.150 --> 13:37.150 --> 13:37.150

13:37.150 --> 13:38.560
これが完璧な例だ。

13:38.560 --> 13:43.750
ビューのログインを聞き、その時にコマンドを実行する。

13:43.750 --> 13:49.840
つまり、2つのカップと長い文字列でリスニングしているようなものだ。

13:49.840 --> 13:54.820
ここでは、コントローラがビューの特定のイベントを直接リッスンしています。

13:54.820 --> 13:56.140
これがその例です。

13:56.140 --> 14:00.070
そして、それをもっと幅広いラジオ局のタイプに変換するのです。

14:00.130 --> 14:02.180
ブロードキャスト？

14:02.200 --> 14:03.010
もちろんです。

14:03.010 --> 14:08.230
同じコンテキストにアクセスできるこのプロジェクト全体の懸念は、私たちの4つの層のすべてです。

14:08.230 --> 14:14.170
このプロジェクト全体の中で同じコンテキストにアクセスできるものであれば、私たちはサブスクライブすることができ、送信されたコマンドのログを聞くことができる。

14:14.170 --> 14:15.460
ここで実行される

14:15.460 --> 14:19.240
そして、どのスコープが送信したコマンドなのかは、受信側のスコープにはわからない。

14:19.240 --> 14:22.870
そして、それが通信の分離というグッドプラクティスだと考えています。

14:22.870 --> 14:27.970
このコマンドを実行し、ログイン処理を開始するようサービスに指示します。

14:27.970 --> 14:35.590
ログアウトが起こるたびに、そのビューイベントをコマンドに変換する サービスが完了したら

14:35.590 --> 14:42.010
ログインに成功したら、モデルを直接更新することができます。

14:42.010 --> 14:45.010
コントローラーはモデルに対して読み書きできます。

14:45.010 --> 14:47.020
そして最後にコマンドを送信します。

14:47.020 --> 14:51.310
このように、様々な方法で通信を構成することができます。

14:51.310 --> 14:58.000
例えば、ここではモデルを直接更新してコマンドを送信するのではなく、以下のようにすることができる。

14:58.000 --> 15:05.410
理論的には、モデルを更新するだけで、モデルが更新されたことを知りたがっているすべての関係者が直接

15:05.410 --> 15:07.720
そのモデルを購読すればいい。

15:07.720 --> 15:13.870
別の方法としては、このコントローラーが値を設定することでモデルに直接影響を与えるという方法もある、

15:13.870 --> 15:20.260
コマンドを送信するだけで、そのコマンドを聞くのは別の役割になります。

15:20.260 --> 15:21.640
そしてモデルを更新する。

15:21.640 --> 15:26.890
1つのモデルと1つのコントローラがある単純なプロジェクトの場合、ここで示しているのはおそらく

15:26.890 --> 15:33.610
しかし、もっと大規模なプロジェクトでは、コントローラとモデルのペアを異なる

15:33.610 --> 15:35.440
アプリケーションの異なる領域に対してコントローラとモデルのペアを持つかもしれません。

15:35.440 --> 15:42.100
つまり、あるコントローラーは、「このメッセージを受け取ったら、次のように伝えよう」と言うかもしれない。

15:42.100 --> 15:46.660
というような指示を出す。

15:46.660 --> 15:52.450
これにより、コントローラーのロジックさえも複数のコントローラーに切り離すことができる。

15:52.450 --> 15:56.530
そして最後に、モデルが変化するたびにコマンドを送信する。

15:56.530 --> 15:58.210
今回のデモは以上です。

15:58.210 --> 16:00.280
実行中のアプリをもう一度見てみましょう。

16:00.280 --> 16:01.150
では、ここで。

16:01.150 --> 16:04.150
最後に、実行中の例をもう一度見てみよう。

16:16.350 --> 16:18.240
ここでは正しいパスワードを使います。

16:22.220 --> 16:23.720
成功です。

16:24.610 --> 16:25.990
今回のデモはここまで。
