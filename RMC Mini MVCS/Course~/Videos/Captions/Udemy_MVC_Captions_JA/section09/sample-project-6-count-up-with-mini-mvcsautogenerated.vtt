WEBVTT

00:00.750 --> 00:01.050
よし

00:01.080 --> 00:03.900
では、カウントアップデモを見てみましょう。

00:03.930 --> 00:09.600
これはunityのミニMVCアーキテクチャを使って作られたデモです。

00:09.630 --> 00:16.860
Udemyのコースで、どのように、そしてなぜアーキテクチャが必要なのかを学ぶことができます。

00:16.860 --> 00:22.700
そしてなぜミニMVCがコミュニティ主導の素晴らしいソリューションなのか。

00:22.710 --> 00:27.870
フレームワーク自体も自由に利用できます。

00:27.870 --> 00:30.000
ソースコードで遊んでみてください。

00:30.630 --> 00:34.890
これはMVCアーキテクチャのコンセプトに基づいています。

00:34.890 --> 00:38.790
Udemyのコースでは、以下のような内容を学ぶことができます。

00:38.820 --> 00:40.290
コースの紹介

00:40.290 --> 00:46.890
unityについて、ソフトウェアデザインについて、unityのミニMVCフレームワークについて話します。

00:47.040 --> 00:50.730
そして、それぞれのトピックについて、より深く、より多くの情報を。

00:50.730 --> 00:56.040
サンプルプロジェクトも含まれていますが、今日はもう少し詳しく説明します。

00:56.040 --> 00:56.760
デモです。

00:56.760 --> 01:00.430
特にカウントアップのデモを見てみましょう。

01:00.430 --> 01:02.680
では早速見ていきましょう。

01:04.210 --> 01:07.510
ミニマックスのプロジェクトです。

01:07.510 --> 01:13.330
ダウンロードしてインストールしたら、ここでサンプルをクリックします。

01:13.330 --> 01:17.710
ミニMAXからサンプルをインポートします。

01:17.710 --> 01:24.910
このサンプルはすでにインポートしてあるので、カウントアップしてみましょう。

01:25.480 --> 01:28.660
まずはデモを走らせます。

01:32.550 --> 01:35.430
画面は少し小さいですね。

01:35.430 --> 01:38.220
こんな感じかな？

01:38.250 --> 01:38.700
よし

01:38.710 --> 01:39.560
少し大きくなった

01:39.570 --> 01:44.550
一番シンプルなデモです。

01:44.550 --> 01:49.530
テキストカウントアップのミニ例です。

01:49.530 --> 01:53.360
そして、23番を表示するカウンターボタンがあります。

01:53.370 --> 01:58.770
サービスから読み込むので、0以外の値からスタートすると思います。

01:58.800 --> 02:03.540
ここをクリックして、画面上のどこかをクリックすると、表示されます。

02:03.540 --> 02:06.750
クリックしたまま、一旦停止して、またシーンを始めましょう。

02:07.600 --> 02:10.600
常に23からスタートし、クリックアップします。

02:10.600 --> 02:11.620
コードを見てみましょう。

02:11.620 --> 02:13.330
なぜ23から始まるんだ？

02:14.670 --> 02:15.660
そうだ

02:15.690 --> 02:17.910
クリックしてスクリーンに映す

02:17.910 --> 02:22.610
この例では、必ずしも複雑なアーキテクチャは必要ありません。

02:22.620 --> 02:28.110
この例では、おそらく1つのモノハビで済ませることができるでしょう。

02:28.110 --> 02:31.980
しかし、これは基本的なことを理解するための簡単な方法です。

02:33.390 --> 02:36.510
そして、それをフォートナイトのようなゲームに持ち込むことを想像してみてほしい。

02:36.630 --> 02:38.310
もっと複雑だ

02:38.310 --> 02:40.460
基本的なことはここで学べばいい。

02:40.470 --> 02:43.380
それではシーンの設定を見てみましょう。

02:44.790 --> 02:48.870
ワールドゲームオブジェクトにカメラとディレクショナルライトを設定します。

02:48.900 --> 02:50.670
何も面白いことは起きていません。

02:50.700 --> 02:58.290
そしてunity UIキャンバスにタイトルテキストとステータステキストを配置します。

02:59.010 --> 03:01.110
少し拡大してみましょう。

03:01.140 --> 03:02.160
ほらね。

03:04.730 --> 03:05.660
さあ

03:06.170 --> 03:10.550
次はミニの例。

03:10.550 --> 03:14.000
これがデモを開始するためのモノビアです。

03:14.150 --> 03:20.240
ミニそのものを作成し、ビューとコントローラの概念を取り込みます。

03:20.240 --> 03:21.260
それでは見てみましょう。

03:21.260 --> 03:23.120
ソースコードを開いてみましょう。

03:25.700 --> 03:27.870
えーと、確認してください。

03:30.310 --> 03:34.870
さっきのデモと違って、面白いコードを隠さないようにします。

03:35.640 --> 03:36.290
これでよし。

03:36.300 --> 03:37.770
トップはここだ

03:37.770 --> 03:40.820
これがそのミニ例です。

03:40.830 --> 03:43.680
The Viewの連載フィールドを取り込みます。

03:43.680 --> 03:44.850
では、ここを見てみよう。

03:45.180 --> 03:52.620
ビューの直列化されたフィールドがあるので、このようにビューをドラッグして取り込みます。

03:52.770 --> 03:53.790
コードに戻る

03:53.790 --> 03:59.700
カウントアップ・ミニを作るだけです。

03:59.700 --> 04:01.800
これが一番の親構造。

04:01.800 --> 04:03.950
そして、ビューを渡します。

04:03.960 --> 04:11.010
つまり、シーンにビューを追加したい場合は、通常このパターンを実行します。

04:11.010 --> 04:11.940
このようにする。

04:12.090 --> 04:15.030
次にカウントアップのミニコードを見てみましょう。

04:18.550 --> 04:19.150
よし

04:19.330 --> 04:27.400
カウントアップ・ミニはミニMVCを拡張するもので、その中にこのような部分があります。

04:27.400 --> 04:32.200
4つの層の間のコミュニケーションであるコンテキストを持つことになる。

04:32.230 --> 04:34.420
データストレージであるモデルがある。

04:34.420 --> 04:41.320
ビューはユーザーUIにレンダリングし、ユーザーからの入力を受け取る。

04:41.350 --> 04:47.590
そしてコントローラはビジネスロジックを処理する。

04:47.590 --> 04:52.750
|にできるようにあなたがそれをすることができます本当に出くわすことあなたは、実際には私のパートナーとi約束、誰でも素早くはちょうど無視これらの一見正確にどのように{}人のことを忘れることができます。

04:52.750 --> 04:55.450
外部データを呼び出したい場合のみ必要です。

04:55.480 --> 05:01.300
ローカルマシンからファイルを読み込み、オンラインバックエンドサービスを呼び出します。

05:01.300 --> 05:05.950
例えば、コンストラクタでビューを取得し、それを保存します。

05:06.250 --> 05:10.090
そして、初期化で新しいコンテキストを作成します。

05:10.150 --> 05:14.560
Contextもまた、単なる低レベルのオブジェクトであり、必要な部分である。

05:14.740 --> 05:17.650
それからモデル、サービス、コントローラーを作ります。

05:17.650 --> 05:24.680
この例でよくあるように、コントローラーは他の3つの階層を内部に取り込みます。

05:24.680 --> 05:27.830 
コントローラーがほとんどの作業を行います。

05:27.830 --> 05:34.010
ミニはコントローラーの準備とフィードを行うだけだ。

05:34.010 --> 05:36.040
そしてコントローラーがほとんどの仕事をする。

05:36.050 --> 05:41.840
さて、よくある質問ですが、モデル・ビューとサービス・コントローラーは常に1つで

05:41.840 --> 05:42.560
ということです。

05:42.560 --> 05:44.270
もっとたくさんあってもいい。

05:44.270 --> 05:51.290
このミニがプレーヤーモデル、プレーヤー、サービスのプレーヤーコントローラーをセットアップしているところを想像してみてください。

05:51.290 --> 05:57.680
メタゲームモデル、メタゲームサービス、メタゲームコントローラーがある。

05:57.680 --> 06:04.100
メタゲームとは、ゲームサービスをバックエンドに接続することである。

06:04.100 --> 06:09.890
ユーザーが自分の進捗状況を保存したり、友人とつながったり、ソーシャル機能を共有できるようにする。

06:09.890 --> 06:16.700
|にできるようにあなたがそれをすることができます本当に出くわすことあなたは、実際には私のパートナーとi約束、誰でも素早くはちょうど無視これらの一見正確にどのように{}人のことを忘れることができます。

06:16.700 --> 06:19.580
ここで初期化されます。

06:19.580 --> 06:22.520
では、この3つを見ていこう。

06:22.520 --> 06:24.080
モデルでは

06:25.540 --> 06:26.080
メンバー

06:26.080 --> 06:31.450
画面をクリックすると、23,24,25と数字が表示されます。

06:31.480 --> 06:35.950
このintを単純なintとして保存すればいいわけだ。

06:35.950 --> 06:43.870
私はすべてのデモでobservable intというものを使っている。

06:43.870 --> 06:45.780
イベントもディスパッチします。

06:45.790 --> 06:47.620
データバインディングにとても便利。

06:47.950 --> 06:50.730
ここでは値をゼロにするだけです。

06:50.740 --> 06:55.720
デモを実行すると、23という値から始まる。

06:55.720 --> 06:59.260
なぜなら、ここではゼロから始まるように見えるからだ。

06:59.650 --> 07:01.570
それではサービスを見てみましょう。

07:02.270 --> 07:07.070
このサービスはベースサービスを継承します。

07:07.310 --> 07:10.850
ベースクラスから継承する場合は任意です。

07:10.850 --> 07:16.460
しかし、ここでやりたいことは、ベースとなるサービスを使うことです。

07:17.810 --> 07:20.510
非常に軽量ですが、便利です。

07:20.660 --> 07:25.510
そして、この下に値を保存し、ここでその値を取得します。

07:25.520 --> 07:26.340
23.

07:26.360 --> 07:33.110
つまり、ローカルのテキストファイルをロードし、そのローカルファイルからロードされた値が何であれ、その値を取得する。

07:33.110 --> 07:37.330
テキストファイルから読み込んだ値をモデルにディスパッチします。

07:37.340 --> 07:42.380
このテキストファイルを見てみよう。

07:42.380 --> 07:44.870
リソース、テキスト、テキスト数

07:44.900 --> 07:47.150
22から始まります。

07:47.180 --> 07:49.790
さっきは23って言ってたけど、22から始まるんだね。

07:50.660 --> 07:53.030
だから22から始まるのか。

07:53.040 --> 07:54.190
この値を微調整すると

07:54.200 --> 07:56.000
さて、これは愚かな例だ。

07:56.000 --> 07:59.960
なぜデータモデルは、Cシャープで値をハードコードしないのですか？

07:59.990 --> 08:00.920
確かにそうですね。

08:00.950 --> 08:04.730
しかし、ここではサービスとは何かという例を示したかったのです。

08:04.760 --> 08:09.950
サービスは、ローカルファイルやバックエンドサービスから外部データをロードする。

08:10.280 --> 08:11.720
これで終わり。

08:11.720 --> 08:12.740
これがサービスだ。

08:12.740 --> 08:13.880
次にコントローラーを見てみましょう。

08:13.880 --> 08:15.350
最も複雑な部分だ。

08:16.310 --> 08:19.720
コントローラーはベースコントローラーから拡張されます。

08:19.730 --> 08:23.600
コメントにあるように、ベースからの拡張は常にオプションです。

08:23.960 --> 08:29.990
また、よくある定型的なコードが少しあるので、ここでもそうします。

08:30.080 --> 08:35.330
そして、initializeでUIのテキストを設定します。

08:36.000 --> 08:39.510
そして、先ほど見たサービスを読み込みます。

08:40.450 --> 08:42.790
サービスが読み込まれたら

08:43.910 --> 08:49.160
モデルカウンターの値が、今読み込まれたサービスのものに設定されます。

08:49.160 --> 08:50.890
サービス側がその値を取得します。

08:50.900 --> 08:51.860
22.

08:51.890 --> 08:56.870
モデルにはその値が初期値として渡される。

08:56.870 --> 08:59.850
だからゼロではなく22から始まるんだ。

08:59.930 --> 09:03.920
次に、画面上のどこがクリックされたかを確認します。

09:03.920 --> 09:06.970
そして、もし画面がクリックされたら、この下に降りてみましょう。

09:06.980 --> 09:09.680
モデルを1つ増やします。

09:09.800 --> 09:11.570
これで終わりです。

09:11.600 --> 09:13.640
では、もう1度デモを実行してみましょう。

09:14.940 --> 09:20.880
まだ、どこかに追加されてるんだな。あ、待てよ、実は画面をクリックしたら

09:20.880 --> 09:21.720
その通り。

09:21.990 --> 09:24.060
シーンを読み込む

09:24.060 --> 09:26.000
だからもう一回ロードしてるんだ。

09:26.010 --> 09:27.390
22を読み込みます。

09:27.390 --> 09:30.450
画面をクリックすると23が表示され、これがデモです。

09:30.900 --> 09:32.460
デモはここまで。
