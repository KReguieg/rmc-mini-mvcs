WEBVTT

00:00.170 --> 00:00.500
よし

00:00.500 --> 00:03.080
ここで、弾むボールのデモを見てみましょう。

00:03.110 --> 00:05.900
デモの文字が少し前に出てしまいましたが、これです。

00:05.900 --> 00:09.580
これはミニMVCのコースの一部ですね。

00:09.590 --> 00:14.330
これはunity architectureのコースで購入可能です。

00:14.330 --> 00:19.970
また、ここで紹介しているコードは、コースのフルコードも含め、すべて

00:19.970 --> 00:20.510
GitHubです。

00:20.510 --> 00:21.950
ですから、そちらをご覧ください。

00:21.950 --> 00:30.620
このコースの下のリンクは、Inside Unityのアーキテクチャ、Model view and controllerをやっているところです。

00:30.620 --> 00:31.160
があります。

00:31.160 --> 00:36.560
このコースでは、コース紹介、Unityについて、ソフトウェアデザインについて説明します。

00:36.560 --> 00:42.740
次のスライドでは、ソフトウェア設計をさらに深く掘り下げて、設計原則について見ていきましょう。

00:42.740 --> 00:44.780
デザイン・パターンを見てみましょう。

00:44.780 --> 00:46.160
それは何ですか？

00:46.160 --> 00:49.310
デザインを図式化する方法を調べます。

00:49.310 --> 00:56.090
UMLを使い、ユニティに関する様々なアーキテクチャの選択肢を検討し、ミニMVCにたどり着きます、

00:56.120 --> 01:01.170
これはカスタムフリーのアーキテクチャであり、主要なソリューションである。

01:01.850 --> 01:05.150
コースには4つのサンプルプロジェクトが含まれています。

01:05.150 --> 01:07.790
しかし、今日はさらに多くのデモを紹介します。

01:07.790 --> 01:09.920
それ以外にも10個ほど追加したと思います。

01:09.950 --> 01:13.040
では、バウンシーボールのデモをご覧ください。

01:13.040 --> 01:14.450
それではご覧ください。

01:14.870 --> 01:17.240
サンプルプロジェクトです。

01:17.240 --> 01:23.540
ミニMVCのサンプル・プロジェクトを入手して、Gitの指示に従った場合

01:23.540 --> 01:28.430
repoの指示に従って、サンプルをインポートしてください。

01:28.430 --> 01:30.350
もうすでにインポートしました。

01:30.380 --> 01:37.640
サンプルを見て、moreフォルダにbouncy ball miniがあるのがわかります。

01:37.640 --> 01:39.380
それでは見てみましょう。

01:40.520 --> 01:41.810
そしてこれがデモです。

01:41.810 --> 01:44.120
まずはデモを実行してみましょう。

01:46.100 --> 01:47.690
音声が少し流れます。

01:47.690 --> 01:49.160
聞こえますか？

01:49.950 --> 01:59.220
でも、やってることはunity physicsを使ってボールを表面でバウンドさせて、UIを更新してるだけです。

01:59.250 --> 02:02.060
このデモにはインタラクティブ性はありません。

02:02.070 --> 02:04.500
スペースキーを押せばいいんだっけ？

02:05.320 --> 02:05.530
これで

02:06.610 --> 02:08.410
インタラクティブ機能はありません。

02:08.980 --> 02:14.140
物理演算を行うだけです。

02:14.140 --> 02:18.400
物理がどのように作用しているのかを見てみると、UIが更新されているのがわかる。

02:18.400 --> 02:18.690
02:18.700 --> 02:18.690

02:18.700 --> 02:20.530
では、これがどのような構造になっているのか見てみよう。

02:22.980 --> 02:28.410
このシーンでは、ワールドゲームオブジェクトがカメラとライトを隠しています。

02:28.410 --> 02:29.490
02:29.410 --> 02:29.490

02:29.520 --> 02:36.630
02:36.660 --> 02:36.660 --> 02:36.660 --> 02:36.660 --> 02:36.660 --> 02:36.660 --> 02:36.660 --> 02:36.660

02:36.660 --> 02:38.760
UI要素を見てみましょう。

02:38.790 --> 02:42.090
タイトルとステータスが表示されています。

02:42.090 --> 02:47.550
これがビューで、視覚的に見えるものと音声が再生されます。

02:47.580 --> 02:52.770
音声が聞こえるかどうかは録音ではわかりませんが、バウンス、バウンスしています、

02:52.770 --> 02:54.760
02:54.780 --> 02:54.780

02:54.780 --> 02:56.760
02:54.780 --> 02:56.780

02:57.420 --> 03:00.540
それでは例を見てみましょう。

03:00.540 --> 03:04.050
これはバウンシーボールのミニサンプルと呼ばれるモノビヘイビアです。

03:04.050 --> 03:09.810
そして、ビューをドラッグするだけです。

03:09.810 --> 03:12.540
これで準備完了です。

03:12.540 --> 03:14.190
ソースコードを見てみましょう。

03:16.110 --> 03:17.810
少しズームアウトしてみましょう。

03:17.820 --> 03:19.950
これがその例です。

03:20.040 --> 03:23.970
この例では、ビューをシリアライズされたフィールドとして取り込みます。

03:24.150 --> 03:27.840
そして、ここから開始します。

03:27.840 --> 03:31.920
新しいバウンシングボールミニを作成し、ビューに渡します。

03:31.920 --> 03:37.290
ミニはアプリ全体のラッパーです。

03:37.290 --> 03:41.940
つまり、ソースコードの中でMiniを見かけたら、それが最も親となる構造であることを意味している。

03:41.940 --> 03:45.420
その中にビューを含むいくつかの要素があります。

03:45.870 --> 03:47.460
次にそれを見てみよう。

03:50.920 --> 03:54.250
ビューを開く

03:56.600 --> 03:58.280
景色が広がります。

03:58.310 --> 03:58.860
ごめんなさい.

03:58.880 --> 04:00.890
まずはミニを開きます

04:01.370 --> 04:04.580
ミニでビューエレメントを取ります。

04:04.610 --> 04:07.040
そこにはオーディオコントローラーもあります。

04:07.040 --> 04:11.180
そして、ミニのイニシャライズ内で行うことは以下の通りです。

04:11.210 --> 04:19.700
コンテキストを作成し、モデルコントローラーサービスを作成します。

04:19.700 --> 04:21.400
この一行で

04:21.410 --> 04:28.040
ミニの世界でコントローラーが初期化されるのは、コントローラーが一番多いということだ、

04:28.430 --> 04:32.750
.430 --> 04:32.750 --> 04:32.750 --> 04:32.750 --> 04:32.750

04:32.750 --> 04:36.020
ミニの内部には4つのパーツがある。

04:36.020 --> 04:40.670
そのうちの1つがコントローラーで、コントローラーが最も知識のある部分です。

04:40.670 --> 04:46.550
そのため、コントローラーは他の3つの要素への参照を持ち、「データモデルとは何か？

04:46.550 --> 04:47.450
と言うのです。

04:47.480 --> 04:50.060
ビュー、誰かとやり取りした？

04:50.090 --> 04:52.430
サービス、何か読み込んでくれる？

04:52.430 --> 04:54.830
そのために必要なのがコントローラなんだ。

04:55.520 --> 04:57.780
では、早速モデルを見てみましょう。

04:58.170 --> 05:04.650
このモデルは、何回カウントアップしたのか、最大値はいくらか、という値を保持することになる。

05:04.650 --> 05:07.560
つまり、3回中1回、3回中2回ということになる。

05:07.560 --> 05:12.510
そして、3分の3になったら、3分の1、3分の2にリセットされる。

05:12.510 --> 05:14.580
そうやって2つの値が動くんだ。

05:14.610 --> 05:17.460
この2つの値はゼロに設定されています。

05:17.460 --> 05:21.360
では、最大値を3に設定する方法を見てみよう。

05:22.020 --> 05:23.700
次にサービスを見てみましょう。

05:23.700 --> 05:27.960
サービスレイヤーは外部データを呼び出すためのものです。

05:27.960 --> 05:34.620
もし、あなたのゲームが最初から外部データを必要としないのであれば、このステップは省略できます。

05:34.620 --> 05:36.150
サービスは必要ありません。

05:36.150 --> 05:43.080
しかし、今日のゲームはバックエンドのサービスを呼び出すのが一般的で、ゲーム本体の外部にあるローカルファイルです、

05:43.080 --> 05:49.140
このサービスコンセプトはそのための素晴らしいものです。

05:49.140 --> 05:56.850
ここでは、ローカルのテキストファイルを読み込み、その値をパースして

05:56.850 --> 05:58.830
バウンスカウント

05:58.860 --> 06:01.530
Max では、このテキストファイルを見てみましょう。

06:01.710 --> 06:04.200
リソースのテキストファイルです。

06:04.380 --> 06:07.440
開いてみると "3 "から始まっています。

06:07.440 --> 06:11.280
というわけで、ここで値を持っているのは少し馬鹿げているようだ。

06:11.310 --> 06:14.010
嬰ハ音記号で "3 "をハードコードすればいいんじゃない？

06:14.040 --> 06:17.580
これは単なるデモです。

06:17.580 --> 06:21.330
アプリの外にデータを置いて、それを読み込んでみよう。

06:21.330 --> 06:24.830
例えば、バックエンドからこれを読み込むこともできた。

06:24.840 --> 06:26.190
これでサービスは終了。

06:26.220 --> 06:29.700
3つの値をロードしてコントローラに戻します。

06:30.430 --> 06:31.780
次にコントローラーを見てみよう。

06:31.810 --> 06:36.010
このコントローラーで最後に見ておく必要があるのはこれです。

06:36.740 --> 06:40.820
コメントにもあるようにbase controllerを継承しています。

06:41.060 --> 06:44.570
ちなみに、baseを継承するのはオプションです。

06:44.570 --> 06:48.950
自由な機能を与えるだけですが、これらの例を通して見えてくることがあります。

06:48.950 --> 06:53.590
このアーキテクチャーをセットアップするのに必要なコードがいかに少ないか。

06:53.600 --> 06:59.210
まあ、この例を見て、ボールをバウンドさせたいと思う人もいるだろう。

06:59.210 --> 07:02.690
って言うかもしれない。

07:02.690 --> 07:08.060
しかし、ここでの例は、非常にシンプルなユースケースで基礎を学んだということだ。

07:08.060 --> 07:14.540
次に、あなたのプロジェクトが、マルチプレイヤーメタゲームを管理するフォートナイトの規模にまで成長することを想像してみてください。

07:14.540 --> 07:18.380
選手一人一人、選手と一緒にできること全て。

07:18.380 --> 07:23.270
何千ものクラスがあり、何万行ものコードがある。

07:23.300 --> 07:29.930
このベストプラクティスをモデル・ビュー・コントローラー・サービスに分割することで、あなたのチームでは本当に大きな利益を得ることができる。

07:29.930 --> 07:30.800
プロジェクトに役立ちます。

07:30.800 --> 07:32.510
だから、シンプルに始めるんだ。

07:32.510 --> 07:38.060
アーキテクチャを学ぼうとするとき、よくある悩みだ、

07:38.060 --> 07:42.310
単純なことを成し遂げるために、たくさんのクラスやたくさんのコード行が必要なんだ。

07:42.320 --> 07:48.350
確かにそうだが、基礎的なことを学ぶために投資する時間も必要だ。

07:48.350 --> 07:55.610
だから、プロジェクトの規模が大きくなるにつれて、ソロプロジェクトが3ヶ月で完成するのは素晴らしいことだ。

07:55.610 --> 08:02.000
5人のプロジェクトでも2週間もすれば、次のフィーチャーがどこに行くべきかという疑問はなくなる。

08:02.000 --> 08:07.850
なぜなら、みんな同じアーキテクチャーパターンで一緒に仕事をしているからだ。

08:07.850 --> 08:12.530
をクリックすると、それはビューで始まり、コントローラに移動し、そして

08:12.530 --> 08:13.400
モデルに移動します。

08:13.430 --> 08:14.810
同じ言語を話している

08:14.810 --> 08:21.560
Udemyのコースでは、次のような新しい技術を導入することの利点と費用対効果分析について話している。

08:21.560 --> 08:23.120
これだけのMVC

08:23.120 --> 08:24.800
ここでコントローラーに戻る。

08:24.800 --> 08:29.120
ビューを初期化し、テキストフィールドを作成します。

08:29.120 --> 08:31.820
そのサービスをリッスンする。

08:32.680 --> 08:36.430
そして、サービスがロードされるたびに、その値を取得します。

08:36.460 --> 08:39.670
テキストフィールドから読み込んだ値をモデルに渡す。

08:39.790 --> 08:42.520
そして、ビューを聞いて、「ヘイ、ビュー」と言う。

08:42.520 --> 08:49.630
物理学がボールのバウンドを検出したら、それをここに取り込んで更新する。

08:49.630 --> 08:53.490
バウンスカウントが変更された場合は、いつでもこれを更新します。

08:53.500 --> 08:55.630
もう少し見てみましょう。

08:55.630 --> 08:56.610
掘り下げることができます。

08:56.620 --> 09:02.170
また、コマンドパターンも少しあります。

09:02.170 --> 09:04.060
では、もう一度デモを実行してみましょう。

09:08.740 --> 09:11.680
マイクがバウンドを拾っているのがわかる。

09:13.350 --> 09:14.130
そのまま

09:14.130 --> 09:14.820
ワン ツー スリー

09:14.820 --> 09:15.510
ワン ツー スリー

09:15.510 --> 09:16.290
ワン ツー スリー

09:16.740 --> 09:18.420
カウントアップデモはここまで。
