WEBVTT

00:00.080 --> 00:03.800
では、電卓を上から見ていきましょう。

00:04.520 --> 00:06.320
では、ここからユニティに飛び込んでみましょう。

00:07.300 --> 00:11.350
これがチャットにリンクしたプロジェクトです。

00:11.380 --> 00:17.470
git repoがあるのがわかると思いますが、そのgit repoのインストール方法が書いてあります。

00:17.620 --> 00:24.850
そうしたら、パッケージマネージャでgitの指示に従っていることがわかると思います。

00:24.850 --> 00:26.260
このパッケージがインストールされています。

00:26.260 --> 00:29.080
これがRMK mini MVCsです。

00:29.080 --> 00:33.460
RMKは私のコンサルティング会社、ラヴェーラのマルチメディア・コンサルティングです。

00:33.460 --> 00:35.770
私がリリースするパッケージは全てこの名前です。

00:35.770 --> 00:42.610
そして、ミニMVCのコンセプトは、モデル・ビュー・コントローラー・サービスで、とても軽いフットプリントです。

00:42.610 --> 00:48.460
つまり、最も基本的な一般的なワークフローを処理します。

00:48.460 --> 00:54.160 
今日はこの技術の上に構築され、非常にエレガントで軽量なのでミニです。

00:54.160 --> 00:54.910
(笑)

00:55.000 --> 00:59.950
そして、サンプルの下にある、サンプルとインポートをクリックします。

00:59.960 --> 01:02.410
インポートはもう済んでいるので、これから確認します。

01:02.410 --> 01:06.130
でも、Readmeにはサンプルの取り込み方が書いてある。

01:07.050 --> 01:09.640
では、まず最初のサンプルから。

01:09.660 --> 01:13.920
準備のためにいくつか閉じておきます。

01:14.040 --> 01:19.710
そして、プロジェクト内のassetsにある、moreフォルダから、順を追って見ていきます。

01:19.710 --> 01:23.740
まずはこの電卓のサンプルを見てみましょう。

01:23.760 --> 01:32.490
さて、MVCの構造はすべて、MVCパターンを模倣してフォルダ構造を整理しています。

01:32.490 --> 01:37.020
01:32.490→01:37.020]たまには、自分のビデオが正しい側にあることを確認します。

01:37.050 --> 01:39.480
例えば、自分をこっちにバウンドさせる。

01:39.510 --> 01:41.670
覆いかぶさってしまうこともある

01:41.670 --> 01:45.540
(槙野)そうだね。

01:45.660 --> 01:48.000
もう一度、構成を説明しよう。

01:48.000 --> 01:56.100
モデル・ビューとコントローラーのフォルダがあるので、その親フォルダを開いてみましょう。

01:56.100 --> 01:57.540
そして、ここを見てみましょう。

01:57.540 --> 02:04.680
コードを表示する際に、25行ほどの高さで表示されるように意識してみます。

02:04.710 --> 02:06.030
という具合に。

02:06.030 --> 02:09.580
しかし、私のビデオと重なってはいけない。

02:09.730 --> 02:11.470
では、これについて話そう。

02:11.770 --> 02:16.960
これはプロジェクト全体のキックオフとなるシーンにあるモノビアです。

02:16.960 --> 02:22.120
Unityに慣れ親しんでいる人なら、最低限シーンにゲームオブジェクトが1つあることはご存知でしょう。

02:22.120 --> 02:28.230
モノハビアーが1つあり、そこからプロジェクトのゲームデモなどを開始する。

02:28.240 --> 02:36.460
ここでは、ビューを取得するためのシリアライズされたフィールドを持っています。

02:36.460 --> 02:39.310
ゲームオブジェクトです。

02:39.310 --> 02:44.220
そして、Unityが提供するスタートメソッドで、電卓ミニを作成します。

02:44.230 --> 02:49.540
つまり、Miniというクラスはこの親オブジェクトということです。

02:49.540 --> 02:52.390
この例では通常1つだけです。

02:52.390 --> 02:58.360
ビューをミニに渡してミニを初期化します。

02:58.390 --> 03:01.470
では、デモを実行して、ここで何が起こるか見てみましょう。

03:01.480 --> 03:02.820
大きくしてくれ

03:02.830 --> 03:10.030
Aフィールド、Bフィールド、結果フィールドがあり、それらを足し合わせて

03:10.030 --> 03:10.810
リセットする

03:10.810 --> 03:16.120
追加とリセットがグレーアウトしているのは、ここに何も入力していないからです。

03:16.120 --> 03:18.600
非常に軽いバリデーションが行われていますね。

03:18.610 --> 03:21.910
2+3を足すとします。

03:21.940 --> 03:26.320
足し算ボタンが使えるようになったので、クリックしてみると、結果は5。

03:26.320 --> 03:32.140
リセットをクリックして、5と10を選び、もう一度追加をクリックします。

03:32.140 --> 03:34.180
結果は15

03:34.180 --> 03:41.950
UIが表示され、UI上で何らかの計算が行われ、その計算結果が表示される。

03:41.950 --> 03:44.470
計算結果はUIに戻る。

03:44.500 --> 03:53.110
つまり、MVCの基本的な例として、初心者が作るようなものを分割することができる。

03:53.110 --> 04:00.010
ビューを持ち、UIを持ち、計算を行い、ユーザーを取り込む。

04:00.010 --> 04:02.110
入力が反映される。

04:02.110 --> 04:05.200
しかし、大きなプロジェクトになると、それはスケーラブルではなくなります。

04:05.620 --> 04:08.050
では、このシーンをどう設定するか見てみよう。

04:08.490 --> 04:15.300
それぞれのシーンにワールドゲームオブジェクトを用意しました。

04:15.300 --> 04:18.000
カメラと照明の子オブジェクトがあります。

04:18.000 --> 04:22.380
これはどのシーンにもある基本的なものなので、非表示にしています。

04:22.410 --> 04:24.260
次に電卓を表示します。

04:24.270 --> 04:25.530
それを見てみよう。

04:25.530 --> 04:33.570
これはUnity UIを使っています。

04:33.600 --> 04:39.510
UIツールキットと混同してはいけないが、これは標準的なUIである。

04:39.510 --> 04:42.690
イベントシステムもあります。

04:42.690 --> 04:44.820
(笑)」「(笑)」「(笑)」「(笑)」「(笑)

04:45.540 --> 04:48.480
そして、ここに自分が飛び込んできます。

04:48.480 --> 04:55.050
このスクリプトは、私が追加したカスタムスクリプトです。

04:55.050 --> 04:56.990
.990となります。

04:57.000 --> 05:00.000
それで何をするかというと

05:00.910 --> 05:04.480
そこに保存して、アクセスできるようにする。

05:04.480 --> 05:06.170
これがビューの設定だ。

05:06.190 --> 05:10.890
そして、先ほども言ったように、これがサンプルで、そこにビューをドラッグしています。

05:10.900 --> 05:18.010
多くのMVCでは、Monobehaviourを継承したビューが必要です。

05:18.010 --> 05:24.760
を拡張するビューを持つことができます。

05:24.760 --> 05:28.900
ビューへの参照を例に渡すわけです。

05:28.900 --> 05:31.500
もう一度、例題に戻ります。

05:31.510 --> 05:32.710
これがビューです。

05:32.740 --> 05:33.790
ミニの登場です。

05:33.820 --> 05:35.680
セッティングを見てみよう。

05:37.650 --> 05:39.180
また毎回

05:40.180 --> 05:42.040
ズームを少しワイルドに

05:42.340 --> 05:42.670
よし

05:42.820 --> 05:46.200
これがミニパターン

05:46.210 --> 05:52.750
コンストラクタでAIミニMVCを継承しています。

05:52.750 --> 05:54.490
ビューを取り込みます。

05:54.670 --> 05:58.150
そしてinitializeでコンテキストを作成します。

05:58.180 --> 06:05.410
コンテキストは、モデルのビューとコントローラを同じように通信させるための接着剤です。

06:05.410 --> 06:06.040
システムの中にある。

06:06.040 --> 06:10.600
複数のコンテキストがあれば、複数のミニが存在することになる。

06:10.600 --> 06:16.320
しかし、このプロジェクトを含め、我々のプロジェクトでは通常、ミニは1つ、つまりコンテキストは1つだ。

06:16.330 --> 06:20.500
それは、3つの異なる懸念事項を話し合うための小さなラジオチャンネルのようなものだと考えることができる。

06:21.160 --> 06:25.060
そこでコンテキストを作り、シンプルなコンテキストを作るだけだ。

06:25.090 --> 06:30.250
そして、特定の値を保持するカスタムモデルを作成します。

06:31.010 --> 06:33.680
コントローラを作成します。

06:33.710 --> 06:38.780
コントローラーはビジネスロジックを実行するための接着剤です。

06:38.780 --> 06:44.690
そのため、モデルを取り込み、ビューを取り込み、その2つを互いに対話させることができる。

06:44.690 --> 06:50.000
そして、お決まりのパターンだが、私はこうする。

06:51.570 --> 06:54.150
すべてを明示的に初期化する。

06:54.150 --> 06:56.850
ここでコンテキストを作成します。

06:56.880 --> 06:58.320
モデルを作成します。

06:58.350 --> 06:59.760
コントローラを作成します。

06:59.760 --> 07:02.820
そして、それぞれの初期化を行います。

07:02.850 --> 07:05.760
一般的には初期化の段階ですね。

07:05.760 --> 07:07.890
この段階からが本番です。

07:07.890 --> 07:14.190
もし初期化しなければ、彼らはそこに座っていることになる。

07:14.190 --> 07:16.340
初期化しなければ、そのプロセスは始まらない。

07:16.350 --> 07:20.670
そして、ここで述べたように、初期化の順番はしばしば重要である。

07:20.670 --> 07:26.460
だから、モデル、ビュー、コントローラーの初期化をしなければならない。

07:26.460 --> 07:33.120
すべてのプロジェクトに共通する明確なルールではありませんが、どの依存関係が発生するかによっては

07:33.120 --> 07:37.050
|にできるようにあなたがそれをすることができます本当に出くわすことあなたは、実際には私たち約束、誰でも素早くはちょうど無視これらの一見正確にどのように{}人のことを忘れることができます。

07:37.050 --> 07:40.380
コントローラーは最後に初期化するのが一般的です。

07:40.560 --> 07:41.340
かっこいいね。

07:41.340 --> 07:42.900
それぞれを見てみよう。

07:43.380 --> 07:45.240
電卓モデルです。

07:46.010 --> 07:51.620
MVCフレームワークにおけるモデルは、単なるデータストレージに過ぎません。

07:51.620 --> 07:57.350
ここでは、ビューで見たA、B、結果を保存しています。

07:57.380 --> 08:04.700
ここで、ObservableというミニMVCに含まれるカスタムクラスを使います。

08:04.700 --> 08:09.910
だから、observable INTを見る時はいつでも、それは普通の古いユニティだと思えばいい。

08:09.920 --> 08:16.100
INTは整数を保存するためのものですが、少し特別なパワーがあります。

08:16.130 --> 08:19.190
をディスパッチすることができる。

08:19.190 --> 08:24.440
ここでは3つの異なるintを保存し、それらをすべて000に初期化しています。

08:24.440 --> 08:26.180
これでモデルは完成です。

08:27.490 --> 08:28.900
さて、ここに戻ってきました。

08:28.900 --> 08:30.280
コントローラーを見てみましょう。

08:30.310 --> 08:33.070
コントローラーは少し複雑になりがちです。

08:33.070 --> 08:37.030
ここではインターフェイスIのコントローラーを使っています。

08:37.960 --> 08:44.520
先ほど見たモデルへの参照と、ビューへの参照をここに保存しています。

08:44.530 --> 08:51.610
そして、initializeで、追加ボタンやリセットボタンが押されたときに

08:51.610 --> 08:56.140
クリックされたら、それを聞き返す。

08:56.140 --> 09:03.460
さて、コントローラーがリセットされるたびに、ビューボタンがリセットされます。

09:03.460 --> 09:05.260
モデルの値をリセットします。

09:05.290 --> 09:06.160
とてもシンプルだ。

09:06.160 --> 09:07.030
単純明快。

09:08.190 --> 09:13.890
ここで広告が出されるたびに、コントローラーは実際に何を計算するんだ？

09:13.890 --> 09:20.190
A＋Bで結果が出るんだ。

09:20.220 --> 09:30.060
A、B、resultがobservable int型であることに注意してください。

09:30.060 --> 09:32.940
ドット値で設定する必要があります。

09:32.940 --> 09:37.680
というわけで、observable intのソースとフリーなgitレポをご覧ください。

09:37.680 --> 09:38.310
チャット

09:38.550 --> 09:41.730
しかし

09:43.890 --> 09:51.030
ここで強力なのは、この値を設定するたびにイベントがディスパッチされることです。

09:51.030 --> 09:52.290
システムはそれを聞くことができる。

09:52.320 --> 09:55.920
つまり、軽いデータバインディングの話を始めたということだ。

09:56.070 --> 09:57.210
以上です。

09:57.210 --> 10:01.140
さて、最後にまだ見ていないビューについて説明しましょう。

10:01.140 --> 10:04.500
では、ここで "ザ・ビュー "を見てみましょう。

10:07.150 --> 10:07.750
よし

10:07.750 --> 10:10.810
ビューはmonobehaviourを継承しています。

10:10.810 --> 10:16.870
つまり、MVCのどの要素もMonobehaviourを継承しなければならないという決まりはないのです。

10:18.310 --> 10:19.190
それはあなた次第です。

10:19.210 --> 10:23.050
このような場合は、「Monobehaviour」を拡張する必要があります。

10:23.050 --> 10:26.740
しかし、ビューがモデルの振る舞いを拡張することはよくあることです。

10:26.740 --> 10:31.330
それは、ビューがユーザーの入力を処理するのが一般的だからです。

10:32.180 --> 10:34.520
ユーザーにグラフィックを表示し、レンダリングする。

10:34.520 --> 10:38.030
そして、unityの世界では、マナビーバーがその手助けをする。

10:38.210 --> 10:42.710
ってことで、追加ボタンとリセットボタンがクリックされた時のunityイベントを作ってみました。

10:42.740 --> 10:44.330
ここでいくつかの設定をします。

10:44.390 --> 10:52.010
UIエレメントをリッスンしているので、ここではunityイベントを使ってテキストフィールドの変化をリッスンしています。

10:53.090 --> 11:00.530
テキストフィールドの値が変わったら、モデルの値が変わったら。

11:00.530 --> 11:06.070
だから、ここではAを、ここではBを、そしてここでは結果を聞いているんだ。

11:06.080 --> 11:11.030
そしてその結果が変わったら、テキストを更新します。

11:11.030 --> 11:13.430
これが双方向バインディングだ。

11:13.430 --> 11:20.810
もしユーザーが入力フィールドにタイプした場合、その入力はここでリッスンされ、モデルに送られます。

11:20.810 --> 11:26.840
モデルが追加やリセットによって変更された場合は、それをビューに戻します。

11:26.840 --> 11:29.360
そこでデータバインディングを行います。

11:29.360 --> 11:37.100
そしてこの下で、リセットボタンをグレーアウトし、追加ボタンをグレーアウトする追加のステップを行います。

11:37.100 --> 11:42.170
フィールドに有効な入力がない場合は、ここでチェックします。

11:43.380 --> 11:44.670
他には？

11:44.670 --> 11:51.810
そうですね、ユーザーが追加ボタンをクリックしたら、カスタムイベントの追加をディスパッチします。

11:52.080 --> 11:53.940
では、もう一度デモを実行してみましょう。

11:55.330 --> 11:58.510
大きくして......。

12:01.400 --> 12:03.950
まあ、その分コードを隠蔽してたかもしれないけど。

12:04.870 --> 12:05.150
うーん

12:05.640 --> 12:06.420
おっと。

12:06.430 --> 12:09.010
右サイドに飛び出す。

12:09.130 --> 12:09.910
というわけで

12:10.850 --> 12:14.770
1＋1でリセットしてみる。

12:14.950 --> 12:18.130
そして2＋2で足すと

12:18.250 --> 12:20.170
これがその結果だ。

12:20.170 --> 12:22.210
電卓のデモはここまで。
