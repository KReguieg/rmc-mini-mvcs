WEBVTT

00:00.290 --> 00:00.740
よし

00:00.740 --> 00:04.940
ゲーム内でチュートリアルをする方法について話しましょう。

00:06.730 --> 00:14.230
まず第一に、なぜゲーム内のチュートリアルがエンドユーザーの体験に役立つのか、そしてなぜそれが難しいのかについて。

00:14.230 --> 00:15.280
開発者にとっては難しいことなのでしょうか？

00:15.310 --> 00:25.000
ゲームというものは、その世界観やインタラクションの仕方について十分なルールがあるものです、

00:25.000 --> 00:30.010
(笑) --> 00:25.000 --> 00:30.010 ゲームの世界やインタラクションの仕方、入力の仕方など、ゲームには十分なルールがあります。

00:30.370 --> 00:37.180
チュートリアルとは、ゲームプレイの最初の1分、10分、1時間の間に

00:37.180 --> 00:39.490
ユーザーに追加情報を与えます。

00:39.490 --> 00:46.720
そのため、あるキャラクターに近づくと、会話を始めるためのボタンの押し方を説明するのです。

00:46.720 --> 00:51.430
そのゲームを5時間もやれば、いちいち説明する必要はなくなる。

00:51.430 --> 00:57.640
つまり、これは一時的なものであり、多くの場合、ユーザーが最初に遭遇した時に行われるものなのだ。

00:57.640 --> 00:58.360
何か

00:58.540 --> 01:01.840
だから、今すぐ必要なんだ。

01:01.840 --> 01:03.100
なぜ挑戦的なのか？

01:03.130 --> 01:06.260
まあ、いつもそうなるとは限らないからね。

01:06.260 --> 01:10.370
普通はゲーム機能を作ったら、いつでもここで使えるようにするものだけどね。

01:10.370 --> 01:15.460
最初の1分、10分、1時間だけでいいんです。

01:15.470 --> 01:21.530
つまり、すべてのゲームシステムを使って、それぞれのゲームにこう言わせることができる。

01:21.530 --> 01:26.030
01:21.530 --> 01:26.030 最初の10分間は余計なことをするな。

01:26.030 --> 01:30.530
しかし、それは様々なシステムに組み込まなければならないコードになる。

01:30.530 --> 01:34.960
チュートリアルの方法について説明します。

01:34.970 --> 01:40.970
チュートリアルについて何も知らないコア・ロジックにチュートリアルをさせる。

01:40.970 --> 01:47.810
チュートリアルのロジックはチュートリアルのことを何も知らず、チュートリアルのロジックはチュートリアルのことを何も知らず、チュートリアルのロジックはチュートリアルのことを何も知らず......。

01:47.810 --> 01:53.900
もしそれが消えてしまったら、コア・ゲームはそのことを知らないし、知ることもない。

01:53.900 --> 01:54.920
01:53.900 --> 01:54.920

01:54.920 --> 01:56.870
では、どのような効果があるのか見てみましょう。

01:57.650 --> 02:04.070
さて、このトークとデモシーンは、より大きなコースの一部です。

02:04.070 --> 02:06.920
unityコースです。

02:06.950 --> 02:12.740
このコースは有料で、この機能がどのように機能するのかサンプルを見ることができます。

02:12.740 --> 02:15.110
ソフトウェアデザインの理論について

02:15.110 --> 02:16.700
ここではその詳細について説明します。

02:16.700 --> 02:22.430
デザインパターン、デザイン原則、UML、ダイアグラムの学習、様々なデザインパターンについて。

02:22.460 --> 02:26.360
02:22.460 --> 02:26.360 ユニティアーキテクチャの種類と、なぜそれが必要なのか。

02:26.930 --> 02:33.020
unityアーキテクチャの種類と必要な理由を説明します。

02:33.020 --> 02:40.010
そして、よりエラーのないワークフローを構築することができる。

02:40.700 --> 02:42.650
様々なものが含まれています。

02:42.680 --> 02:48.740
このコースが最初に作られてから、10以上のデモが追加されました。

02:48.740 --> 02:52.550
そのうちのひとつがチュートリアルのやり方です。

02:52.910 --> 02:54.830
それではunityに飛び込んでみましょう。

02:55.580 --> 03:05.240
Gitから、あるいはコースの一環として、mini MVCsパッケージを無料で入手したら、ダウンロードしてインストールします。

03:05.240 --> 03:07.300
をダウンロードしてインストールします。

03:07.310 --> 03:11.840
そしてサンプルタブでサンプルをインポートします。

03:11.840 --> 03:14.680
そして、それを横から見ていきます。

03:14.840 --> 03:15.950
もうやったよ

03:15.950 --> 03:24.560
チュートリアルミニを開くと、プレハブがいくつかあるのがわかります。

03:24.560 --> 03:31.370
チュートリアルビューとチュートリアルコントローラがあります。

03:31.490 --> 03:33.350
これを実行してみましょう。

03:40.760 --> 03:45.580
このチュートリアルに入る前に見せたいものがあります。

03:45.590 --> 03:46.640
でかいのを作るよ

03:47.870 --> 03:56.090
このシーンにあるチュートリアルは、上隅にあるチュートリアルと書かれたボックスの中にあります。

03:56.090 --> 03:57.770
ユーザー名とパスワードを入力してください。

03:57.800 --> 04:04.010
ここでは簡単のために、ウェブでの操作方法を真似ています。

04:04.040 --> 04:07.130
多くの場合、私たちはウェブ体験にログインしている。

04:07.130 --> 04:14.120
ユーザー名とパスワードを入力し、ログインする。

04:14.120 --> 04:21.530
この例は、このチュートリアルと核となる部分がどのように分かれているかを説明するために、別のシーンに置かれています。

04:21.530 --> 04:22.880
このチュートリアルとコアなゲームロジックは別物です。

04:22.880 --> 04:29.000
ログインミニは別シーンとして用意しましたので、そのシーンをじっくりとご覧ください。

04:29.000 --> 04:35.480
ユーザー名、パスワード、ログインボタン、ログアウトボタンがいくつ使えるかわかる。

04:35.480 --> 04:39.920
パスワードは1,2,3,4と表示されます。

04:39.920 --> 04:46.550
"パスワードは1:39.920 --> 04:46.550" "名前を入力します

04:47.480 --> 04:48.200
こんな感じ

04:49.490 --> 04:53.660
パスワードを入力します。

04:55.360 --> 05:02.440
パスワードを入力し始めると、チュートリアルは最初にユーザー名とパスワードを入力するように指示します。

05:02.440 --> 05:03.190
パスワード

05:03.190 --> 05:09.010
しかし、ユーザー名を入力し、パスワードを入力し始めた瞬間に、「あ、これはもしかして......」となる。

05:09.010 --> 05:10.720
ログインをクリックします。

05:10.720 --> 05:18.640
これは、チュートリアルがどのようにコアの進捗状況を調べているかについての任意の例です。

05:18.640 --> 05:22.140
ユーザーエクスペリエンスに役立つヒントを与えてくれる。

05:22.150 --> 05:26.530
|にできるようにあなたがそれをすることができます本当に出くわすことあなたは、実際には私のパートナーとi約束、誰でも素早くはちょうど無視これらの一見正確にどのように{}人のことを忘れることができます。

05:26.530 --> 05:32.740
Aボタンをクリックすると対話が始まります。

05:32.740 --> 05:34.840
をクリックするとダイアログが始まります。

05:34.840 --> 05:35.180
そうだろ？

05:35.260 --> 05:36.370
こちらも同じです。

05:36.370 --> 05:39.700
これは横に座って情報を見せています。

05:39.700 --> 05:44.230
一時的にしか見られないかもしれません。

05:44.230 --> 05:51.880
チュートリアルがあることをゲーム自体は知らないということです。

05:52.300 --> 05:52.870
そうだろ？

05:53.350 --> 05:54.700
ログインをクリックします。

05:54.700 --> 05:55.730
失敗しました

05:55.730 --> 05:58.130
チュートリアルに失敗しました。

05:58.130 --> 06:01.250
ログアウトしてパスを使ってみる。

06:01.250 --> 06:02.540
1、2、3、4

06:02.540 --> 06:05.600
ヒントの通り、これが本当の答えです。

06:05.630 --> 06:06.470
ログインします。

06:06.470 --> 06:10.070
チュートリアルを完了したと表示されます。

06:10.070 --> 06:12.920
チュートリアルは横の方にあり、役立つヒントを与えてくれます。

06:12.920 --> 06:15.730
確かに、ここに表示されているよりもずっと多くのヒントを与えてくれるかもしれない。

06:15.740 --> 06:17.960
その構造を見てみよう。

06:19.050 --> 06:27.150
チュートリアルビューのUIです。

06:28.640 --> 06:29.190
これだ。

06:29.210 --> 06:30.520
タイトルと本文です。

06:30.530 --> 06:32.420
隅っこの方に鎮座してますね。

06:32.420 --> 06:33.710
シンプルなUnityのUI。

06:35.740 --> 06:42.700
ミニはこのビューを参照します。

06:42.970 --> 06:45.370
ミニの構造を見てみましょう。

06:47.230 --> 06:48.760
ここにコメントがあります。

06:48.760 --> 06:49.630
ちょっと読んでみます。

06:49.660 --> 06:53.170
サンプルはデモのメインエントリーです。

06:53.440 --> 06:56.990
チュートリアルは別のシーンを読み込む必要はありません。

06:57.010 --> 07:03.850
これは、全く関係のないコードでもきちんと装飾できることを示すためだけに行われています。

07:03.880 --> 07:07.360
.これは、全く関係のないコードであり、システムの上でユーザーエクスペリエンスを正しく装飾することができることを証明するためのものである。

07:07.360 --> 07:10.660
だから、このシーンにすべてを集約させることができる。

07:10.660 --> 07:16.300
でも、このログインの例を読み込めば、このように分離することができるんだ。

07:16.300 --> 07:17.230
上に置くことができる。

07:17.230 --> 07:21.190
その分離の図解がいいんだろ？

07:21.580 --> 07:23.920
では、ここで「ザ・ビュー」を取り上げます。

07:24.950 --> 07:30.510
さて、デモシーンのほとんどは、実際、このデモシーンを除くすべてのデモシーンに付属しています。

07:30.510 --> 07:32.870
ミニはワンシーンのデモです。

07:32.930 --> 07:41.990
しかし、ここでもミニをロードした後、ミニの例でログインしてロードします、

07:42.140 --> 07:44.600
これはログイン部分だけです。

07:44.600 --> 07:50.630
このチュートリアルは、このデモのずっと前に作られたもので、チュートリアルの上にある

07:50.630 --> 07:50.900
チュートリアルのことは何も知らない。

07:50.900 --> 07:53.450
このために更新する必要すらなかった。

07:53.630 --> 07:57.620
そしてミニへのブリッジを作る。

08:02.760 --> 08:03.840
そして

08:07.330 --> 08:09.040
ここで配線をする。

08:09.250 --> 08:15.880
ブリッジの作成では、ロードしたシーンからモデルを取得します。

08:15.880 --> 08:17.800
上のコードを見てほしい。

08:17.800 --> 08:24.790
チュートリアルでは、ロードされたシーンのモデルを見る必要があります。

08:24.790 --> 08:25.600
となります。

08:25.840 --> 08:36.640
そこで、コアロジックのコンテキストを使用してビューを初期化し、チュートリアルコントローラを作成します。

08:36.640 --> 08:37.390
ここで

08:38.330 --> 08:41.570
ログインモデルとビューを渡します。

08:41.660 --> 08:44.930
これがチュートリアルのロジックです。

08:44.930 --> 08:47.930
コントローラを見てみましょう。

08:52.110 --> 08:58.830
チュートリアルを更新して、チュートリアルという小さなウィンドウを表示させ、チュートリアルを開始します。

08:58.830 --> 08:59.790
をクリアにする。

08:59.910 --> 09:04.230
そして、ログインモデルのリスニングを開始。

09:04.470 --> 09:07.150
追加シーンを読み込む

09:07.170 --> 09:14.100
Miniを使用して作成されたので、そこからログインモデルを取得します。

09:14.100 --> 09:18.390
ログインできますか？

09:19.010 --> 09:23.180
そして、いくつかのコマンドを聞く。

09:23.300 --> 09:25.820
ログインしたら

09:28.030 --> 09:31.630
ログインボタンが有効になります。

09:31.630 --> 09:35.820
だから、ログインができるようになる。

09:35.830 --> 09:44.020
そして、ログアウトのコマンド、ログインのコマンド、そしてログインのコマンドを受信する。

09:44.020 --> 09:45.730
ログイン完了

09:45.730 --> 09:48.610
ということで、4つのことを聞くことができました。

09:48.610 --> 09:56.500
理論的には、チュートリアルとコアロジックを同時に開発する場合、このステップでは

09:56.500 --> 09:57.340
のようになる。

09:57.340 --> 10:03.310
このような基本的な構造を理解した上で、例えば「歩く」というアイデアを導入したとしよう。

10:03.310 --> 10:06.220
10:03.310→10:06.220.RPGゲームのキャラクターと会話する。

10:06.220 --> 10:13.810
このコアログインモデルでは、キャラクターと対等な会話を開始したようなイベントを公開する必要があります。

10:13.810 --> 10:14.470
真。

10:14.500 --> 10:19.960
あるいは、ここに会話開始コマンドという新しいコマンドがある。

10:19.990 --> 10:26.470
どちらであっても、ゲームのコアロジックの一部として、更新され、ディスパッチされるようにしたい。

10:26.500 --> 10:33.260
チュートリアルはこのように、モデルを通して、あるいは

10:33.260 --> 10:37.490
コンテキストコマンドマネージャーを使用して、これらの情報を聞くことができます。

10:37.640 --> 10:45.200
つまり、コアロジックでログアウトが発生するたびに

10:45.200 --> 10:53.180
チュートリアルのテキストを更新して、最初のフレーズ "OK, it's time to enter login, enter username "を入力します。

10:53.180 --> 10:53.990
とパスワードを入力する。

10:54.440 --> 11:01.430
いつでもログインできるように変更されましたが、これはコアロジックがこの時点でログインできるようにする必要があることを知っているためです。

11:01.430 --> 11:02.510
ログインできるかどうか？

11:02.540 --> 11:07.340
チュートリアルが再び更新され、もう少し詳しい情報が表示されます。

11:07.700 --> 11:15.680
チュートリアルが更新され、もう少し詳しい情報が表示されます。

11:15.680 --> 11:21.920
ログインが完了すると、チュートリアルは「ログインに成功しました。

11:21.920 --> 11:25.790
チュートリアルが成功すれば成功、失敗すれば失敗です。

11:25.820 --> 11:29.360
つまり、ここは任意のデモというわけだ。

11:29.720 --> 11:32.120
これはちょっとくだらない例ですね。

11:32.780 --> 11:34.910
このようなフォームにヘルプを出す

11:34.910 --> 11:40.520
しかし、ゲームではコアロジックの様々な部分が必要になることは想像に難くないでしょう。

11:40.520 --> 11:43.370
チュートリアル・システムに公開する。

11:43.580 --> 11:50.450
つまり、理論的には2つの異なるチームがあり、1つのチームではその分離を説明することができます。

11:50.450 --> 11:55.730
チュートリアルのロジックやその他のシステムを担当することもできる。

11:55.730 --> 12:01.490
しかし、私はここで分離について示しただけで、それらはすべてログインモデルを通して話しています。

12:01.490 --> 12:02.270
コマンド

12:02.270 --> 12:03.170
それで終わりです。

12:03.200 --> 12:05.390
では、再びデモを走らせて見ましょう。

12:07.120 --> 12:12.220
画面の大部分は別のシーンから読み込まれている。

12:12.220 --> 12:15.450
チュートリアルで読み込まれたことを何も知りません。

12:15.460 --> 12:22.060
チュートリアルが一番上に表示され、隅に少しだけ表示されます。

12:22.060 --> 12:23.050
チュートリアル

12:23.050 --> 12:25.000
ユーザー名とパスワードを入力します。

12:25.000 --> 12:27.400
ユーザー名とパスワードを入力します。

12:27.400 --> 12:29.860
ログインをクリックします。

12:30.520 --> 12:31.800
ログインをクリックします。

12:31.840 --> 12:33.610
結果待ちと表示されました。

12:33.610 --> 12:35.410
そして、「失敗しました。

12:35.470 --> 12:37.150
ログアウトをクリック

12:37.180 --> 12:39.310
チュートリアルがまた変わる。

12:39.340 --> 12:43.020
これでいくつか入力できるようになったので、ここで正解を入力します。

12:43.030 --> 12:44.080
1、2、3、4

12:44.320 --> 12:45.310
クリックしてログイン

12:45.340 --> 12:46.720
結果待ちと表示されます。

12:46.720 --> 12:49.250
チュートリアルを終了しました。

12:49.270 --> 12:55.960
まるでコアロジックの一部であるかのように、しっかりと統合されている。

12:55.960 --> 12:56.920
分離

12:56.920 --> 13:02.740
このチュートリアルの利点の1つについて、このビデオの前半で述べました。

13:03.870 --> 13:09.030
このチュートリアルの利点は、最初の1分間だけチュートリアルを実行することです。

13:09.240 --> 13:14.730
チュートリアルを無効化すれば、ゲームロジックはチュートリアルを知る必要はない。

13:14.730 --> 13:16.020
チュートリアルについて

13:16.020 --> 13:18.290
チュートリアルが有効になっているかどうかを知る必要はありません。

13:18.300 --> 13:22.020
あるいは、設定メニューがあり、その設定にあることを想像してみてください。

13:22.020 --> 13:23.010
このボックスにチェックを入れる。

13:23.010 --> 13:27.470
チュートリアルが必要な場合は、チュートリアルが不要な場合は、このボックスにチェックを入れてください。

13:27.480 --> 13:33.270
また、この隅にある小さなウィンドウのオン・オフを切り替えることもできます。

13:34.360 --> 13:34.770
素晴らしい

13:34.780 --> 13:36.160
デモはここまで。
