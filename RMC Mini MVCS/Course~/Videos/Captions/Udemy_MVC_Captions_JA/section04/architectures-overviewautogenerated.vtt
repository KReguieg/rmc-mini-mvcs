WEBVTT

00:00.330 --> 00:02.580
次にアーキテクチャを見てみよう。

00:03.000 --> 00:08.190
ソフトウエア・アーキテクチャとは、すべての部品の基本的な構成です。

00:08.190 --> 00:13.880
アーキテクチャは設計原理とパターンの上に構築されることがわかります。

00:13.890 --> 00:18.210
これらの利点は、再現可能な問題に対する実証済みのソリューションであることです。

00:18.210 --> 00:25.080
オーダーメイドの方法でプロジェクトを編成することで、信頼性、拡張性、パフォーマンス、および、チームワークを向上させることができる。

00:25.080 --> 00:26.490
をもたらすことができる。

00:26.490 --> 00:32.670
ソフトウェア・アーキテクチャは一般的に高レベルであり，様々な言語やプラットフォームに適用することができる、

00:32.670 --> 00:39.420
また，それを使うことによって，より迅速な開発が可能になり，メンテナンスの段階でも時間を節約することができる。

00:40.560 --> 00:46.140
私たちは開発者として新機能を追加することが仕事であり、それが大部分だと考えがちですが、それは間違いです。

00:46.140 --> 00:53.880 
我々の経験の80%はコードのメンテナンスに費やされている。

00:54.000 --> 01:00.660
そのため、アーキテクチャや設計原則、パターンを前もって選択し、それをプロジェクト全体に適用することで、プロジェクトを成功に導くことができるのです。

01:00.660 --> 01:06.960
プロジェクト全体を通して適用することで、機能を追加していく際の大規模なメンテナンス・フェーズがより簡単になり、プロジェクトの質を向上させることができるのです。

01:06.960 --> 01:09.180
クオリティ・オブ・ライフを高いレベルから引き上げることができる。

01:09.180 --> 01:15.960
アーキテクチャーには、典型的な若いチームや個人によるノー・アーキテクチャー・アプローチもある。

01:17.550 --> 01:23.550
プロジェクトの大きな展望やビジョンを持たずに、その場その場で正しいと思うことをやる。

01:23.550 --> 01:25.080
でも、最終的にはどうなるか。

01:25.080 --> 01:26.400
他に必要なものがある

01:26.400 --> 01:32.790
ベテランチームは、チーム独自のニーズを見て、カスタムアーキテクチャーソリューションを使うことができる。

01:32.790 --> 01:39.420
そのような原則やパターンをライブラリとして採用し、そのような製品を作成するのだ。

01:40.710 --> 01:46.830
このアプローチには長所と短所があり、もう一つの重要なタイプは確立されたアーキテクチャを使用することである、

01:46.830 --> 01:52.460 
既成のアーキテクチャーを使うことだ。

01:52.470 --> 02:01.740
MVP、VC、VMなど、他にもたくさんあります。

02:02.010 --> 02:08.700
このように、その場その場で正しいと思ったことをそのまま実践していくのは、ごく自然なことだと感じている。

02:08.700 --> 02:11.190
アーキテクチャのないアプローチには欠点がある。

02:11.190 --> 02:16.710
個人であろうと、小さなチームであろうと、それぞれの機能をどのように追加するかについて、より多くの議論があるだろう。

02:16.710 --> 02:22.860
レシピがないため、一人の開発者の寿命が延びたり、開発者間で矛盾が生じたりする。

02:22.860 --> 02:28.110
チーム内の各開発者間で矛盾が生じないということは、再要素の適用がより困難になるということだ。

02:30.840 --> 02:37.100
1日後、1週間後、1年後のコードを読むのはより難しくなる。

02:37.110 --> 02:43.410
また、新しいメンバーを加えたり、プロジェクトからメンバーを外したりする場合、より多くのことが必要になります。

02:43.410 --> 02:44.640
労力がかかる。

02:44.670 --> 02:47.430
説明の手間が増える

02:47.430 --> 02:52.260
新しいデベロッパーはコードベースを理解するために多くの時間を費やす必要がある。

02:52.260 --> 02:57.990
そして、開発者が去るたびに、その開発者の個人的なカスタムについて説明し、文書化しなければならない。

02:57.990 --> 03:00.540
そのプロジェクトにどのように適用したかを説明し、文書化しなければならない。

03:00.540 --> 03:06.180
さて、多くの開発者、特に初心者にとって、このアプローチはまだ最速の方法のように感じられるかもしれない。

03:07.590 --> 03:14.160
そして、プロトタイプの段階で開発者がこれらのルールを窓から投げ捨て、ノーアーキテクチャを行うのをよく見かける。

03:14.160 --> 03:14.790
というアプローチをとる。

03:14.790 --> 03:21.090
しかし、そのような高速なコードは確かにプロジェクトに多くのバグと複雑さをもたらす。

03:21.090 --> 03:23.910
バグのコストは時間とともに指数関数的に増大する。

03:24.150 --> 03:30.090
バグを早期に発見できれば、修正も早く、プロジェクト全体への影響も少なくなります。

03:30.090 --> 03:35.820
調査によると、製品を出荷した後に同じバグを発見した場合、その30倍もの時間がかかるという。

03:35.820 --> 03:40.950
そのバグを修正して新バージョンをリリースするのはもっと難しい。

03:40.950 --> 03:46.770
だから、ベストプラクティスは、最初からメンテナンス可能なコードを作成し、自動化を促進することだ。

03:46.770 --> 03:52.440
テストについては後述するが、バグを早期に発見し、頻繁に修正することである。

03:52.440 --> 03:56.040
を修正することです。

03:56.040 --> 04:02.550
ソフトウェアの研究によると、バグの80％以上は機能の20％程度で起こるそうです。

04:02.580 --> 04:08.610
これらは、すべてをつなぎとめる接着剤のような核となる部分や、素早く動作するアーキテクチャとなりうる。

04:08.610 --> 04:14.820
アーキテクチャのために新機能を追加したり、アーキテクチャのないアプローチはますます多くの問題を引き起こす。

04:14.820 --> 04:15.420
時間が経てば経つほど

04:15.420 --> 04:23.160
また，多くの人にとって非常に意外なことだが，ソフトウェアプロジェクトにおける開発者の人生の80%以上，その80%は

04:23.160 --> 04:27.360
はコードベースのメンテナンスであり、必ずしも新しい機能を追加するわけではない。

04:27.360 --> 04:33.630
だから、一日中機能追加をしていると思うかもしれないが、それは全体の仕事量のごく一部なのだ。

04:33.630 --> 04:41.160
つまり、ここでの重要なポイントは、その20%の新機能と特徴を効率的に長期的に行うことである。

04:41.160 --> 04:47.220
コードベースのメンテナンスに時間を費やすことで、その恩恵を享受することができる。

04:47.220 --> 04:47.790
一緒にね。

04:47.790 --> 04:56.220
MVCのような確立されたアーキテクチャを使うことで、ユニティ開発において多くの利点が得られることがわかるだろう。

04:56.580 --> 04:59.850
このセクションのテーマのひとつは、多くの場合

05:00.040 --> 05:04.870
ソフトウェア開発の進め方について私たちが抱いている考えは、現実と一致しないことが多いということです。

05:04.960 --> 05:10.840
私たちは一日中新しい機能を追加しているように感じていますが、実はそれは寿命のほんの一部なのです。

05:11.650 --> 05:17.350
メンテナンスがより簡単になるような長期的な解決策を考え始めたとき、私たちはより高い評価を下すことになる。

05:17.350 --> 05:23.690
05:23.690→05:23.710→05:23.710→05:23.710

05:23.710 --> 05:25.240
このセクションは以上です。

05:25.240 --> 05:25.990
ありがとうございました。
