WEBVTT

00:00.520 --> 00:03.490
Unity MVCフレームワーク。

00:03.490 --> 00:10.750
UnityのUMBCフレームワークは、数年前に当時の私の学習と私のアーキテクチャに基づいて作りました。

00:10.750 --> 00:11.460
目標です。

00:11.470 --> 00:17.140
この特別なフレームワークを使うことの利点は、実績があること、そしてそのフレームワークの多くに基づいていることです。

00:20.320 --> 00:26.080
このバージョンはユニティ用としてのみ存在するが、理論上、そこにあるパターンは言語にとらわれない。

00:26.080 --> 00:28.920
を選択すれば、異なるプラットフォームにも対応させることができます。

00:28.930 --> 00:35.740
コードの各領域が分離され、デカップリングされるため、よりテストしやすい環境をユニティにもたらします。

00:35.740 --> 00:39.940
そして、多くの確立されたアーキテクチャのように、unityも見てきました。

00:39.940 --> 00:45.010
これは、より迅速な開発と、プロジェクトにおけるより効率的なメンテナンスを可能にします。

00:45.010 --> 00:50.860
作成当時、私はunityでの開発方法をモノビヘイビア中心の流れで行っていました。

00:50.920 --> 00:53.860
だから、このシステムも同じように動くように作ったんだ。

00:53.860 --> 00:58.300
このシステムの大きな特徴は、monoのビヘイビアを多用していることです。

00:58.300 --> 01:01.780
4つの関心事はそれぞれモノビヘイビアを拡張しています。

01:01.780 --> 01:07.060
つまり、それぞれの関心事をゲームオブジェクトにぶら下げることができる。

01:07.060 --> 01:12.550
でのフィールドのシリアライズなど、unityでゲームオブジェクトやコンポーネントのために持っているおなじみのワークフローを使うことができます。

01:12.550 --> 01:13.570
のフィールドのシリアライズを含む。

01:13.570 --> 01:17.890
例えば、このスクリーンショットでは、モデルの1つを見ることができます。

01:17.890 --> 01:23.920
このモデルはmonoビヘイビアなので、シリアライズされたフィールドを持つことができ、unityインスペクタにうまく配置することができます。

01:23.920 --> 01:24.250
ビューに表示されます。

01:24.250 --> 01:27.550
では、あなたとVCのハイレベルな構造は？

01:27.550 --> 01:34.090
まあ、以前見たパターンでおなじみのm vがあります。

01:34.090 --> 01:36.130
のようにモノの振る舞いを拡張しています。

01:36.130 --> 01:42.700
それから、ゲームコードの中にアプリのコンセプトを作る。

01:42.700 --> 01:48.430
そして、そのコンセプトの下に、モノのビヘイビアがある。

01:48.430 --> 01:50.740
のアプローチはunityにとてもネイティブな感じがします。

01:50.740 --> 01:55.360
モノはシーン内のゲームオブジェクトに置かれ、好きなように分離できる。

01:55.360 --> 01:58.270
この章では、この概要を説明します。

01:58.270 --> 02:01.000
いずれは別のフレームワークに移行するつもりです。

02:01.000 --> 02:04.480
UMBCのシステムの一部を紹介します。

02:04.480 --> 02:08.680
この古いシステムから学んだことがいくつかある。

02:08.680 --> 02:13.480
まず、ベースとなるコントローラーのように、ジェネリックを使うことだ。

02:13.480 --> 02:19.450
ジェネリックスはC-sharpで再利用可能なテンプレートクラスを作成する素晴らしい方法です。

02:19.450 --> 02:25.840
第二に，このワークフローは強力な型付けを可能にする。

02:25.840 --> 02:27.100
このワークフローは、具体的な試合の流れに即している。

02:27.100 --> 02:32.770
自動補完機能で、プロパティーとメソッドを表示することができます。

02:32.770 --> 02:37.630
このフレームワークはデザインパターンで学んだ概念を導入しています。

02:37.630 --> 02:45.070
私たちは、より分離された形で、高レベルのFAコミュニケーションのためのコマンド・マネージャーと、ユニティーを持っています。

02:45.070 --> 02:48.670
ローカル・レベルの通信のためのイベントです。

02:48.670 --> 02:53.350
ここでの重要な違いは、以前これらのパターンについて話したときに説明したように、コマンドが

02:53.350 --> 02:58.750
managerの概念では送信側と受信側がお互いを参照する必要がないのに対し

02:58.750 --> 03:04.420
Unityのイベントコンセプトではオブザーバーが送信者への参照を持っている必要があります。

03:04.420 --> 03:09.550
これにより、フレームワークは主要な関心事の間でどのように通信できるかを2つの階層に分けることができる。

03:09.550 --> 03:15.490
だから、私がこのフレームワークを作った当時は、私がこのフレームワークにどのようにアプローチするかという原則を受け入れていた。

03:15.490 --> 03:16.690
Unityのプロジェクト。

03:16.690 --> 03:20.410
先ほども言ったように、非常にモノ・ビヘイビア中心のアプローチでした。

03:20.410 --> 03:23.020
このプロジェクトはまだ生きており、活用することができます。

03:23.020 --> 03:27.130
このコースでは、別のフレームワークを選択することをお勧めします。

03:27.880 --> 03:34.690
しかし、このプロジェクトは、私の建築ポートフォリオにおける有効な例として、次のような場所で紹介している。

03:34.690 --> 03:38.440
このセクションでは、全体的にアーキテクチャーについて多くのことを学びました。

03:38.440 --> 03:42.610
どのような確立されたアーキテクチャーを使うか、その長所と短所を見た。

03:42.610 --> 03:47.440
私たちが選択できる主な確立されたアーキテクチャの違いについて話しました。

03:47.440 --> 03:50.710
ノーアーキテクチャーの欠点について。

03:50.710 --> 03:55.960
特に初心者のうちは、それがとても自然に感じられるが、最終的に配当は得られない。

03:55.960 --> 04:01.840
そして、ゲームアーキテクチャを行うために選択できるunity中心のフレームワークのリストを見ました、

04:01.840 --> 04:05.740
私が数年前に作成したyouとVCのプロジェクトも含まれています。

04:05.740 --> 04:11.770
次に、私が最近作った別のフレームワーク、ミニとVCのフレームワークについて説明しましょう。

04:11.770 --> 04:17.260
これは、このコースで学んだ設計原則の集大成です、

04:17.260 --> 04:21.400
デザインパターン、私自身のものも含めた他のアーキテクチャからの学び。

04:21.400 --> 04:26.710
このような、「某有名企業」「某有名企業」「某有名企業」「某有名企業」「某有名企業」「某有名企業」「某有名企業」「某有名企業」「某有名企業

04:26.710 --> 04:32.230
アーキテクチャーに関するこのセクションは特に充実しており、情報量も多かった。

04:32.230 --> 04:38.710
このセクションは特に充実しており、多くの情報を得ることができた。

04:38.710 --> 04:40.540
そして次のセクションに進みます。

04:40.540 --> 04:41.290
ありがとうございました。
