WEBVTT

00:00.360 --> 00:07.050
私たちが選択できる確立されたアーキテクチャのいくつかを詳しく見て、その利点を確認しよう。

00:07.050 --> 00:08.190
MVC

00:09.330 --> 00:15.960
unityのゲームを作る場合、いくつかの異なるアプローチが可能です。

00:15.960 --> 00:16.750
のトピックで、いくつかの異なるアプローチが可能です。

00:16.770 --> 00:26.160
私は6つの異なるスタイルを使って、シンプルな3Dのunityボーリングゲームをゼロから作りました。

00:26.160 --> 00:27.760
00:27.780 --> 00:27.780

00:27.780 --> 00:29.650
そのうちのいくつかがここにリストアップされている。

00:29.670 --> 00:34.620
上から順に、初心者の開発者にとって自然に感じられるものです。

00:34.770 --> 00:41.220
私はこれをノー・アーキテクチャ・アプローチと呼んでいます。

00:41.220 --> 00:43.530
を3つのDオブジェクトに関連付けることです。

00:43.530 --> 00:49.980
だから、unityを学ぶ時にはボーリングの玉にボーリングの玉のコードを入れたり、ピンにピンのコードを入れたりするんだ。

00:49.980 --> 00:51.830
これは自然なやり方だと思う。

00:51.840 --> 00:57.240
その際に問題になるのが、3つのDオブジェクトをそれぞれ独立させる方法です。

00:57.240 --> 00:59.220
ということだ。

00:59.220 --> 01:05.430
この先、おそらくもう少し経験を積んだ人なら、この3つのオブジェクトのほとんどを

01:05.430 --> 01:13.200
を参照している。

01:13.200 --> 01:16.350
ボーリングのボールへの参照は次のステップに進むだろう。

01:16.350 --> 01:22.530
これは、空の碁や空のゲームオブジェクトが、次のステップを促進することができるため、通信の一部をスムーズにします。

01:22.650 --> 01:23.940
可能性のある問題

01:23.940 --> 01:30.450
この場合、空のゲームオブジェクトは各オブジェクトのライフサイクルを正確に把握していないことになります。

01:30.450 --> 01:36.570
ワールドの立ち上げやゲームプレイの一時停止、要素のタイミングを把握するのに問題があるかもしれません。

01:36.570 --> 01:37.580
01:36.570 --> 01:37.580

01:37.590 --> 01:43.260
このゲームを作るベテラン開発者や小さなチームは、カスタムアーキテクチャを試すかもしれない。

01:43.260 --> 01:48.870
彼らは学んだ優れた設計原則やデザインパターンを使って、それをいくつかの

01:48.870 --> 01:50.060
01:50.060 --> 01:50.060

01:50.070 --> 01:54.840
私の経験では、ここに座っているチームの大半はカスタムアーキテクチャを使っている。

01:54.840 --> 01:57.210
利点は柔軟性が高いことです。

01:57.210 --> 02:02.730
このようなソリューションを作るには、より多くの知識と経験が必要です。

02:02.820 --> 02:08.000
そして、そこで生じる問題には、プロジェクトごとに車輪を再発明することが含まれる。

02:08.010 --> 02:08.940
そうだな

02:08.940 --> 02:13.560
しかし、複数のプロジェクトを管理する場合、それは可能です。

02:13.560 --> 02:16.980
|にできるようにあなたがそれをすることができます本当に出くわすことあなたは、実際には私のパートナーとi約束、誰でも素早くはちょうど無視これらの一見正確にどのように{}人のことを忘れることができます。

02:16.980 --> 02:23.040
また、新しいスタッフを雇う際には、あなた特有のアーキテクチャ・ソリューションについて教育する必要がある。

02:23.040 --> 02:23.760
プロジェクトごとに

02:23.760 --> 02:26.340
最後に、確立されたソリューションを使用することである。

02:26.340 --> 02:31.260
既成のソリューションをプロジェクトに適用することは多くの利点がある。

02:31.260 --> 02:32.820
実証済みだから

02:32.820 --> 02:36.900
(柴崎)それは...(柴崎)その通りだ。

02:36.900 --> 02:42.840
しかし、柔軟性に欠け、冗長な印象を与えることもある。

02:42.840 --> 02:47.790
特に開発の初期には、単純なことを達成するためにかなりの量のコードが必要になります。

02:47.790 --> 02:53.280
また、チームの各メンバーや新しく加わる人は、その特定のフレームワークを知っておく必要がある。

02:53.280 --> 02:56.280
ある意味、それは簡単なことだ。

02:56.280 --> 03:00.900
彼らはすでに、あなたが選んだ特定の確立された枠組みのためのスキルを持っているかもしれません。

03:00.900 --> 03:01.980
(勿論、そのようなことはない。)しかし、その学習曲線は注目に値する。

03:01.980 --> 03:07.980
数十年にわたるソフトウェア開発の結果、今日私たちが目にするアーキテクチャの多くは

03:07.980 --> 03:08.880
03:07.980 --> 03:08.880

03:08.880 --> 03:16.110
その中でも特に人気があるのは、コア機能を3つか4つに分割することや

03:16.110 --> 03:17.850
その上でコミュニケーションをとる。

03:17.970 --> 03:24.180
一般的なアイデアとしては、それぞれが特定のニーズを持つ課題を解決するものであり、それは理にかなっている。

03:24.180 --> 03:30.570
このように、モデル・ビュー・プレゼンター・モデル、ビュー、ビュー、ビュー、ビュー、ビュー、ビュー、ビュー、ビュー、ビュー、ビュー、ビュー、ビュー、ビュー、ビュー、ビュー、ビュー、ビュー、ビュー、ビュー、ビュー、ビュー、ビュー、ビュー、ビュー、ビュー、ビュー

03:30.570 --> 03:38.280
ビュー、モデル、モデル・ビュー・コントローラー（MVC）モデル・ビュー・プレゼンターは、コードを3つの異なるものに整理する。

03:38.280 --> 03:38.940
ユニット

03:38.940 --> 03:44.400
プレゼンターは真ん中に位置し、他の階層を整理・調整します。

03:44.670 --> 03:47.730
この場合、プレゼンターはユーザーからのインプットを受け取ります。

03:47.730 --> 03:51.930
主に、プレゼンターがビューとレンダリングの調整を行います。

03:51.930 --> 03:57.540
また、ユーザーとのインタラクションが多く、ビューが頻繁に更新されるような場合、これは非常に有効な手段です。

03:57.540 --> 03:58.230
解決策です。

03:58.230 --> 04:01.350
モデル・ビュー・モデルもよく似ている。

04:01.350 --> 04:07.680
3つの関心事、つまり3つのコード領域に分かれており、ここではビューモデルが真ん中に位置している。

04:07.680 --> 04:12.180
ビューモデルは入力を処理し、ビューとのレンダリングを調整します。

04:12.180 --> 04:17.370
また、ユーザーとのインタラクションがあり、ビューが頻繁に更新される場合にも理想的です。

04:17.370 --> 04:19.530
MVCもよく似ていますね。

04:19.530 --> 04:22.620
ここではコントローラーを真ん中のオブジェクトとしています。

04:22.620 --> 04:26.070
厳密なMVCでは、入力を処理するのはコントローラーです。

04:26.070 --> 04:32.190
モデルからデータを取り出し、ビューのレンダリングに必要なデータを渡す。

04:32.190 --> 04:37.740
また、複数のモデルと複数のビューがある場合に、その複雑さを調整するのに理想的です。

04:37.740 --> 04:42.060
結局のところ、この一連の確立されたアーキテクチャーはよく似ている。

04:42.060 --> 04:48.210
彼らは皆、生活の質全体を向上させるために、プロジェクトの懸念事項を分離しようとする。

04:48.210 --> 04:50.580
|にできるようにあなたがそれをすることができます本当に出くわすことあなたは、実際には私のパートナーとi約束、誰でも素早くは

04:50.580 --> 04:55.740
UIやビューをデータから切り離すことは非常に重要である。

04:55.740 --> 04:57.810
ここでの違いは非常に微妙だ。

04:57.810 --> 05:03.270
もちろん、ネーミングが少し違うだけでなく、実際に見ることができる動作も違う。

05:03.270 --> 05:06.590
には、それぞれの選手固有の動作がある。

05:06.600 --> 05:08.790
とりあえず、MVCを深く見てみよう。

05:09.110 --> 05:12.440
このパターンの中で一番好きなものを選んで先に進みます。

05:12.470 --> 05:18.980
モデル・ビュー・コントローラーとは、コードを3つの主要な関心事に分離するアーキテクチャです。

05:18.980 --> 05:26.420
要約すると、モデルは実行時のデータを扱い、ビューはUIとユーザーからの入力を扱う。

05:26.450 --> 05:30.260
また、オーディオビジュアルもユーザーにレンダリングする。

05:30.260 --> 05:31.880
そして、コントローラーが接着剤となる。

05:31.880 --> 05:36.530
このコントローラーを使うことで、ゲームロジックを調整することができます。

05:36.530 --> 05:43.460
MVCでは一般的にコントローラーがユーザーからの入力を管理します。

05:43.460 --> 05:49.880
私のMVCやunityを使う他の多くのアプローチでは、ビューに入力を処理させます。

05:49.880 --> 05:55.690
それは微妙な違いで、unityが伝統的な意味での入力とどのように関係しているかに関係しています。

05:55.700 --> 06:01.970
しばしば私たちは、モノビヘイビア、モニタービヘイビア、入力を処理する手助けをするビューを考えます。

06:01.970 --> 06:02.600
フィットしている。

06:02.600 --> 06:09.470
つまり、ビューで入力を処理し、それをコントローラに渡すということです。

06:09.470 --> 06:12.080
に渡す。

06:12.080 --> 06:18.290
今日のゲームはバックエンドサービスや他のプレイヤーとのマルチプレイに接続されていることが多い。

06:18.290 --> 06:19.010
ライブ

06:19.160 --> 06:21.260
サービスレイヤーを導入。

06:21.260 --> 06:27.470
では、MVCで説明したことに加えて、もうひとつレイヤーを追加してみましょう。

06:27.470 --> 06:30.860
はモデルとは異なる外部データを扱う。

06:30.860 --> 06:36.260
さて、このコースの残りの部分では、MVCとMVCを同じ意味で使うことがあります。

06:36.260 --> 06:43.070
同じソリューション、同じ基本プランで、サービスレイヤーがあったり、あるいは

06:43.070 --> 06:43.640
そうではない。

06:43.640 --> 06:47.150
そのレイヤーが必要かどうかによって、そのレイヤーはオプションと考えることもできる。

06:47.150 --> 06:53.540
全体として、MVCの確立されたアーキテクチャを使用すると、多くの機能と利点があります。

06:53.540 --> 06:59.180
確立されたアーキテクチャは、私たちが成功を見てきた原則やパターンに基づいて構築されていることが証明されています。

06:59.180 --> 07:04.160
そのため、理論的には異なる言語やプラットフォームに移植することができる。

07:04.160 --> 07:06.650
そのような場合にも、このようなシステムは役に立ちます。

07:06.650 --> 07:12.350
学習曲線はあるが、最終的にはこのようなアーキテクチャを使うことで、より迅速な開発が可能になる。

07:12.350 --> 07:17.300
また、プロジェクトの寿命の大半はメンテナンスに費やされることが分かっているので、我々は

07:17.300 --> 07:22.010
|にできるようにあなたがそれをすることができます本当に出くわすことあなたは、実際には私のパートナーとi約束、誰でも素早くはちょうど無視これらの一見正確にどのように{}人のことを忘れることができます。

07:22.010 --> 07:30.320
さらに、MVCsのプロジェクトは、より読みやすく、よりテストしやすく、これらの異なるプロジェクトがどのように結合されているのか、より分離されている。

07:30.320 --> 07:31.850
(註:MVCの場合)。

07:31.850 --> 07:37.550
私たちのプロジェクトで必要であれば、専用のサービスレイヤーがあります。

07:37.550 --> 07:44.060
ワークフローの利点だけでなく、私たちのプロジェクトはすべてバージョン管理上にあり、コミットすることで共同作業を行っています。

07:44.060 --> 07:50.330
バージョン・コントロールにコミットすることで、コミットの摩擦を減らすことができる。

07:50.330 --> 07:56.960
というのも、コードベースが小さなスニペットに分割されるからだ。

07:56.960 --> 07:57.890
07:57.890 --> 07:57.890

07:57.890 --> 08:03.080
特にゲーム開発やユニティにおいて、健全な議論が行われていることは注目に値する。

08:03.080 --> 08:06.470
コミュニティでは、MVCのようなものを使うことに反対している。

08:06.500 --> 08:13.100
MVCのようなものを使用することについては、特にゲーム開発やunityコミュニティで議論があります。

08:13.100 --> 08:14.930
08:14.930 --> 08:14.930

08:14.930 --> 08:19.490
MVCを擁護する意見として、その学習曲線は努力に値するというものがある。

08:19.490 --> 08:24.410
さらに、開発者の頭の中では、私たちはしばしば「人生とは追加することだ」と考えていると述べた。

08:24.410 --> 08:28.580
を追加することだと考えがちであり、メンテナンスという本当の重要な段階を忘れてしまっている。

08:28.670 --> 08:34.850
だから、他のものを使う方が簡単だと感じるかもしれないが、MVCは最終的に優れたワークフローを生み出すのだ。

08:34.850 --> 08:41.600
もう一つの議論は、unity自体がデータバインディングを備えていないということだ。

08:41.600 --> 08:45.020
MVCのためのアーキテクチャのパターンを確立することができない。

08:45.020 --> 08:50.870
確かにデータバインディングを使えば、これを適用するのは簡単ですが、別の解決策もあります。

08:50.870 --> 08:52.250
そのいくつかを見てみよう。

08:52.340 --> 08:57.980
特に、以前のセクションでお話ししたobservableクラスは、次のようなものです。

08:57.980 --> 08:59.870
で解決できる。

08:59.870 --> 09:03.830
バインディングのようなものが簡単に手に入ります。

09:03.830 --> 09:10.580
もうひとつの意見は、通信が切り離され、より多くのステップを通過するため、次のようになります。

09:10.580 --> 09:14.000
MVCのような確立されたアーキテクチャでは最適化されない。

09:14.000 --> 09:18.110
ゲームは最適化が必要なタイプのソフトウェアであることも分かっている。

09:18.110 --> 09:20.660
この評価には同意できない。

09:20.660 --> 09:27.530
しかし、チームとしての仕事の大部分は、必ずしも以下のような狭い部分にあるわけではない。

09:27.530 --> 09:29.840
入力のキャプチャとグラフィックのレンダリング。

09:29.840 --> 09:36.980
この問題を解決する一つの簡単な方法は、メニューやソーシャル機能といった大きなメタゲームを用意することです、

09:36.980 --> 09:44.240
高得点テーブル、インベントリ管理、UIに対する複雑さなど、すべて確立された

09:44.240 --> 09:50.060
|にできるようにあなたがそれをすることができます本当に出くわすことあなたは、実際には私のパートナーとi約束、誰でも素早くはちょうど無視これらの一見正確にどのように{}人のことを忘れることができます。

09:50.060 --> 09:54.560
MVCの外側に位置し、より結合された、より迅速な方法で通信する。

09:54.560 --> 09:56.360
素晴らしいハイブリッドソリューションだ。

09:56.360 --> 10:01.940
そして最後に、確立されたアーキテクチャーを使うということは、すべての新しいボタンが

10:01.940 --> 10:07.940
10:01.940 --> 10:07.970 --> 10:07.970 --> 10:07.970 --> 10:07.970 --> 10:07.970 --> 10:07.970 --> 10:07.970 --> 10:07.970

10:07.970 --> 10:08.980
作成する危機

10:08.980 --> 10:11.560
今後のスライドでもう少し詳しく見てみよう。

10:11.560 --> 10:12.870
そうですね

10:12.880 --> 10:19.540
UIをゲームに組み込むには、2、3ステップではなく、4、5ステップくらい必要です。

10:19.540 --> 10:24.940
その具体的な例では、特に最初のうちは、2、3の余分なステップを踏むのは面倒に感じるかもしれません、

10:24.940 --> 10:30.070
しかし、これは結局のところ、心配事を切り離して考えることの利点の表れなのだ。

10:30.070 --> 10:32.980
機能追加の最初の20%は

10:32.980 --> 10:38.680
慣れが必要だが、その恩恵はより大きなものに適用される。

10:38.680 --> 10:40.780
コードベースの維持の80%に適用される。

10:40.780 --> 10:45.580
このように、リファクタリングがより確実に行われるようになりました。

10:45.580 --> 10:50.770
バグが発生しにくくなり、発生しても解決しやすくなった。

10:50.770 --> 10:52.900
参考リンク

10:52.900 --> 10:57.550
パースペクティブについてもう少し知りたい方は、ぜひご覧ください。

10:57.550 --> 10:57.940
だから

10:57.940 --> 11:01.780
全体として、それぞれのソフトウェア開発ツールには長所と短所があります。

11:01.780 --> 11:08.650
このコースでは、MVCのような確立されたアーキテクチャを学ぶことで、それを上回る利点があることを示します。

11:08.650 --> 11:09.520
その欠点は

11:09.520 --> 11:13.900
VCは懸念事項の分離から始めましょう。

11:13.900 --> 11:15.160
振り返ってみましょう。

11:15.160 --> 11:21.100
モデルは実行時のデータを扱い、コントローラーはその中間に位置し、通信を調整する。

11:21.100 --> 11:23.710
また、ゲームロジックの大部分も含まれています。

11:23.710 --> 11:29.410
ビューはUIやユーザーからの入力を処理し、グラフィックや音声をレンダリングします。

11:29.560 --> 11:33.510
サービスレイヤーは外部からのデータコールを処理します。

11:33.520 --> 11:39.640
例えば、あなたのゲームがハイスコアを投稿するバックエンドシステムと連携する場合、その規約は次のようになる。

11:39.640 --> 11:45.490
MVCを使用する際の注意点としては、参照と関係者間のコミュニケーションに気をつけることです。

11:45.490 --> 11:47.850
MVCを使用する上で重要なのは、各コンサーン間の参照とコミュニケーションに注意することです。

11:47.860 --> 11:52.720
それぞれのコンサドーレは、基本的に全く違うことをする。

11:52.720 --> 11:55.360
だから、それらの変更を分離したいんだ。

11:55.360 --> 11:57.520
通信表を見てみよう。

11:57.520 --> 12:03.670
そこには多くの情報があるが、主な情報は、コントローラーが以下を送受信しているということだ。

12:03.670 --> 12:05.380
通信の大部分は

12:05.380 --> 12:09.760
モデルはデータに関することしか知らないような間抜けなものにしたい。

12:09.760 --> 12:14.740
ビュー自体はUIと入力の処理しかできないような間抜けなものにしたい。

12:14.740 --> 12:19.870
直接やり取りをしないのがいい。

12:19.870 --> 12:24.820
そして、ほとんどのコミュニケーションにおいて、サービスがモデルのように振る舞うことがわかる。

12:24.820 --> 12:28.180
このサービスもまた、自分のデータだけを扱う、間抜けなものなのだ。

12:28.180 --> 12:33.280
さて、これらのうちのひとつに新規参入する場合、確立されたアーキテクチャを学び始める場合

12:33.280 --> 12:39.790
MVCやVCのように、様々な関係者とのコミュニケーション方法に柔軟性を持たせることができます。

12:39.790 --> 12:44.590
MVCやVCは、様々な関心事とのコミュニケーションに柔軟性を与えてくれる。

12:44.590 --> 12:49.690
UIボタンのような単純なものを作るのに、かなりのステップを踏む必要がある。

12:49.690 --> 12:50.140
クリック

12:50.140 --> 12:52.990
ここでまず、複雑さの範囲を見てみよう。

12:52.990 --> 12:59.100
もし、MVCを使わず、ノーアーキテクチャのアプローチをとった場合、どのようにボタンを聞くのだろうか？

12:59.110 --> 13:05.440
もし、ボタンをクリックするゲームがあって、ボタンをクリックすることでテキストが更新され、あなたが勝つとします。

13:05.470 --> 13:06.940
とてもシンプルなゲームです。

13:06.940 --> 13:09.960
2つのステップを踏めばいいんだ

13:09.970 --> 13:16.480
Unity UIを使用していると仮定すると、そのUIのクリックイベントをリッスンして、次のように処理します。

13:16.480 --> 13:18.040
をカスタムコードで処理する。

13:18.040 --> 13:19.290
これは2つのステップだ。

13:19.300 --> 13:25.720
MVCのような確立されたアーキテクチャーを使うと、さらにいくつかのステップが必要になることがわかる。

13:25.720 --> 13:30.760
これは、これらの懸念が最も冗長なフレーバーで分離されているためです。

13:30.760 --> 13:33.370
そのボタンを処理するための5つのステップを見てみよう。

13:33.370 --> 13:33.880
クリック

13:33.880 --> 13:41.140
ビューボタンがメッセージを発信し、コントローラーがそれを処理し、モデルを更新し、そして

13:41.140 --> 13:42.820
モデルがメッセージを送っている。

13:42.820 --> 13:49.000
13:42.820 --> 13:49.000 おい、更新されたぞ。

13:49.000 --> 13:54.130
このリストでは、イベントが使用されたのか、コマンドが使用されたのかを入れ替えています。

13:54.130 --> 13:56.970
この区別はコードでもう少し詳しく見ることができる。

13:56.980 --> 14:02.740
結局のところ、私がチームに勧めたいのは、このどちらかを選んで、それに従うということだ。

14:02.740 --> 14:09.610
例えば、開発の初期段階では一貫して5番を適用し、感覚をつかむ。

14:09.610 --> 14:10.330
そのために

14:10.330 --> 14:16.630
もし、5段階から4段階に短縮したいのであれば、それはあなた次第です。

14:16.630 --> 14:17.290
を決める。

14:17.290 --> 14:23.020
しかし、一貫性のあるアプローチと、よりデカップリングされたアプローチは、配当があることを覚えておいてほしい。

14:23.050 --> 14:28.540
このプロセスには、私たちが規定する部分もあり、少し混乱するかもしれない。

14:28.540 --> 14:32.500
このプロセスには、従わなければならない規定的な部分もあれば、このようなさまざまな選択肢のような柔軟性もある。

14:32.500 --> 14:38.380
MVCの使い方に慣れてきたら、完璧にすることにあまりこだわらない方がいいと思う。

14:38.560 --> 14:44.550
MVCの使い方に慣れてきたら、完璧を求める必要はないと思います。

14:44.560 --> 14:47.470
もう一つのボーナスは、このプロジェクトの後半にあります。

14:47.470 --> 14:54.040
もしアプローチを変えたくなった場合、リファクタリングがより簡単になります。

14:54.040 --> 14:55.840
MVCの方がずっと簡単だ。

14:55.840 --> 15:01.270
たとえ適用方法に微妙な違いがあったとしても、パターンそのものは

15:01.270 --> 15:07.750
このような一貫性は、あなた方のこれまでのアプローチには欠けていたものであり、私たちの議論に必要なものです。

15:07.810 --> 15:14.890
私たちは、MVCまたはMVCをお気に入りのフレームワークとして選択し、これがどのように適用されるかを確認しながら前進するつもりです。

15:14.890 --> 15:17.020
をunityに適用して良い感触を得たいと思います。

15:17.020 --> 15:22.630
研究の一環としてフレームワークを選ぼう このコースのために、私は様々なunityを見てきました。

15:22.630 --> 15:23.410
アプローチ

15:23.410 --> 15:29.530
中には開発チームのブログ記事の説明だけで、コードがないものもあります。

15:29.530 --> 15:31.340
|にできるようにあなたがそれをすることができます本当に出くわすことあなたは、実際には私たち約束、誰でも素早くはちょうど無視することができます。

15:31.360 --> 15:37.870
しかし、特注の確立されたアーキテクチャがたくさんあるので、それを利用することができる。

15:37.870 --> 15:38.680
ユニティのために

15:38.800 --> 15:41.710
私が使って遊んだもののいくつかはここにあります。

15:41.710 --> 15:47.530
このコースをすべて終えた後、またこれらのフレームワークのどれかを試したくなったら、ぜひここに来てください。

15:47.530 --> 15:48.450
15:47.530 --> 15:48.450

15:48.460 --> 15:53.980
このコースの残りの部分で学ぶ原則は、どのようなMVCのアプローチにも応用できます。

15:53.980 --> 15:54.790
15:53.980 --> 15:54.790

15:54.820 --> 15:57.880
そのうちの2つは私が作成したものです。

15:57.880 --> 16:08.230
You MVCは数年前に作ったRCによるもので、ミニMVCはこのコースのためだけに作った。

16:08.230 --> 16:11.170
そして、なぜそれを勧めるのか、その方法と理由について、さらに詳しく学びます。

16:11.170 --> 16:17.950
MVCのソリューションをユニティに導入する際、なぜ少々複雑化する必要があるのか、特別に説明しよう。

16:17.950 --> 16:21.460
unityはすでにオーダーメイドの構造を持っているからです。

16:21.460 --> 16:24.520
それについては以前のセクションで少し話した。

16:24.520 --> 16:30.310
unityはシーンとゲームオブジェクトをベースにしていて、その間のコミュニケーションは

16:30.310 --> 16:34.180
コンポーネントとゲームオブジェクトの通信はUnity内部で行われます。

16:34.180 --> 16:39.700
unity自体がMVC構造で作られているわけではないことに注意しましょう。

16:39.880 --> 16:45.220
unityにはこの3つを1つにまとめた懸念領域がある。

16:45.220 --> 16:52.420
例えば、unityのプロジェクトで最も重要なクラスはmonoです。

16:52.420 --> 16:53.200
ビヘイビア

16:53.200 --> 16:55.660
特に初心者のうちは。

16:55.660 --> 16:59.290
モノ・ビヘイビアのサブクラスがある。

16:59.290 --> 17:03.400
monoビヘイビアと例を使うだけで、unityが崩壊するのがわかる。

17:03.400 --> 17:05.260
様々な懸念がある

17:05.260 --> 17:10.870
"enabled "タグや "transform "などのプロパティを持つモデルのようなものだ。

17:10.870 --> 17:17.320
ビューのようなもので、入力ループやグラフィックスのレンダリングを内部から行います。

17:17.320 --> 17:21.220
monoビヘイビアのライフサイクルの中で、コントローラのように振る舞います。

17:21.220 --> 17:26.950
このような、「モノ」のライフサイクルの中で、「モノ」のような振る舞いをするようになりました。

17:26.980 --> 17:32.440
また、「リファレンス」と呼ばれる直列化された概念があるため、様々な問題に対処することができる。

17:32.440 --> 17:34.480
モナークの動作の外側にあるかもしれない。

17:34.480 --> 17:39.880
そして、このコースの残りの部分を通して、MVCのコンセプトをユニティに取り入れることを見ていくうちに、これは

17:39.880 --> 17:40.900
を覚えておいてください。

17:40.900 --> 17:47.440
Unityは他のプラットフォームと同様、ユニークな特徴を持っています。

17:47.440 --> 17:49.870
アーキテクチャの概念を現実のunityの世界に持ち込まなければなりません。

17:49.870 --> 17:55.510
以下にリンクされているいくつかのリソースをご覧ください。

17:55.510 --> 18:00.340
そしてもちろん、ドキュメンテーションのスクリプトリファレンスです。

18:00.340 --> 18:01.690
を参照してください。

18:01.690 --> 18:06.880
さて、どのようなアーキテクチャを考え、それをunityに取り込むか、あるいはカスタムで

18:06.880 --> 18:09.880
を作成する場合、いくつかの考慮事項があります。

18:09.880 --> 18:13.930
フレームワークやアーキテクチャはユニティに特化した機能を持っているか？

18:13.930 --> 18:16.060
君主ビヘイビアの役割は？

18:16.060 --> 18:19.840
unityの世界ではとても重要ですが、賛否両論あります。

18:19.840 --> 18:22.570
建築はモナークビヘイビアを使うのか？

18:22.570 --> 18:28.270
このアーキテクチャーでは、さまざまな関心事や関心事間のコミュニケーションをどのように扱うのですか？

18:28.270 --> 18:33.370
そういえば、全体的な硬直性と柔軟性のレベルは？

18:33.370 --> 18:36.520
このセクションでは、多くの新情報を得た。

18:36.520 --> 18:42.820
デザイン原則とデザインパターンの基礎が、より大きな世界である

18:42.820 --> 18:43.900
アーキテクチャー

18:44.140 --> 18:49.660
我々は，確立されたアーキテクチャをチームに導入する際のユニークな課題をいくつか見てきた。

18:49.660 --> 18:51.610
また、その利点もいくつか見てきた。

18:51.610 --> 18:57.820
そして、unityは他のプラットフォームと同じように、独自の特異性や特定の機能を持っていることがわかった。

18:57.820 --> 19:03.520
そしてどんなアーキテクチャを選択するにしても、unityの世界にうまく適合させたいのです。

19:03.610 --> 19:04.720
今はここまで。

19:04.720 --> 19:05.470
ありがとうございました。
