WEBVTT

00:00.210 --> 00:02.340
ユニットテストの概要。

00:02.340 --> 00:04.220
まずは文脈を少し。

00:04.230 --> 00:11.790
プロジェクトが大きくなり、スクリプトやメソッドが増え、複雑になってくると、ユニットテストを確実に行うことが難しくなります。

00:11.790 --> 00:14.610
新しいコードが古いコードを壊さないようにするのは難しいことです。

00:14.640 --> 00:20.020
自動化されたテストは、あなたのコードが期待通りに機能しているかを確認するのに役立ちます。

00:20.040 --> 00:26.640
自動化されたテストは、バグがどこでどのように発生するのかをプロセスの早い段階で発見してくれます。

00:26.640 --> 00:31.140
エンドユーザーがバグを報告してくれるのを待つという、よりコストのかかる方法ではなくね。

00:31.140 --> 00:37.650
つまり、テストなしでMVCアーキテクチャーを使うこともできるし、MVCアーキテクチャーなしでテストを使うこともできる。

00:37.650 --> 00:41.140
では、なぜこれらのトピックを一緒に話すことが重要なのでしょうか？

00:41.160 --> 00:46.860
それは、この2つの技術の組み合わせが、アーキテクチャを使うことで信じられないほど強力になるからです。

00:46.860 --> 00:48.090
MVCのような。

00:48.120 --> 00:54.450
MVCのようなアーキテクチャーを使うことで、コードがより分離され、各クラスが単一の目的を持ち、解決策を提供できるようになります。

00:54.450 --> 00:55.140
よりシンプルになります。

00:55.140 --> 00:58.060
これらは全て、よりテストしやすいコードの特徴でもある。

00:58.080 --> 01:04.740
プロジェクトにテストを加えることで、堅牢性と信頼性が増し、シンプルな解決策を促すことができます、

01:04.740 --> 01:09.090
01:04.740 --> 01:09.090 テスト駆動開発では特にそうです。

01:09.090 --> 01:12.690
プロジェクトやワークフローにユニットテストを追加することで、時間を節約することができます。

01:12.690 --> 01:15.620
計画、開発、メンテナンスの手間が省けます。

01:15.630 --> 01:21.450
コードに自信が持てるようになる。

01:21.450 --> 01:22.460
01:21.450 --> 01:22.460

01:22.470 --> 01:29.010
01:21.450 --> 01:22.470 --> 01:29.010 大規模なリファクタリングの前にすべてのテストを実行することを考えてみてください。

01:29.010 --> 01:31.530
01:31.530 --> 01:31.560 --> 01:31.560

01:31.560 --> 01:33.750
テストは芸術であり、科学でもある。

01:33.750 --> 01:38.480
もっと研究し、もっと練習することで、開発者はそれぞれ自分の芸術を開発することができる。

01:38.490 --> 01:43.050
01:38.490→01:43.050低レベルテストはユニットレベルでテストすることです。

01:43.620 --> 01:49.200
個々のメソッドと、そこから生まれるソフトウェアの実践と進化。

01:49.200 --> 01:56.370
また，アーキテクチャの選択，依存関係，あるいはその欠如について，より高度な議論を促すこともできる。

01:56.370 --> 02:00.840
また、そのようなシステムがどのように結合しているのか、あるいは結合していないのかについても。

02:00.870 --> 02:06.980
これはすべて、ソフトウェアに優れた組織をもたらすという、より大きな会話の一部なのです。

02:06.990 --> 02:13.530
私たちの最初の目標は、特にテストを始めたばかりの人は、特定のメソッドが期待通りのものであることを確認することである。

02:13.530 --> 02:14.300
の結果を得ることである。

02:14.310 --> 02:21.060
それができたら、今度は予期せぬ条件やコーナーケースを想定してテストすることができる。

02:21.060 --> 02:24.390
クラスの構造そのものを分析することができます。

02:24.390 --> 02:28.230
そして、そのクラスが置かれているシステムの目的に目を向けることができる。

02:28.230 --> 02:35.430
そして、このような分析は、私たちに大規模な

02:35.430 --> 02:37.290
02:37.290 --> 02:37.290

02:37.290 --> 02:37.980
ソフトウェアで

02:37.980 --> 02:43.250
テストには様々な種類があり、それを知ってか知らずか、あなたはすでにテストを行っている。

02:43.260 --> 02:46.980
その代表的なものがスモークテストです。

02:46.980 --> 02:50.730
このテストは "私のために働くかどうか "という気軽なテストです。

02:50.730 --> 02:55.380
私たちの多くは、これが唯一のプロジェクトテストかもしれない。

02:56.030 --> 03:03.050
新しいコードを書くたびに、ユーザーのようにアプリを実行し、プレイヤーのようにゲームをプレイする。

03:03.050 --> 03:08.300
アプリやゲームの特定のパスが、期待通りに動くかどうかを確認するんだ。

03:08.330 --> 03:14.210
そして、定期的に、おそらく毎週ビルドした後に、何人かのユーザーを招待するユーザーテストがある。

03:14.210 --> 03:16.340
を招待します。

03:16.370 --> 03:21.880
ここではバグがないかだけでなく、ユーザーの期待に応えられているかどうかをチェックします。

03:21.890 --> 03:23.840
そういうプレイは楽しいか？

03:23.840 --> 03:30.320
そして、ユニットテストでは、体験のごく一部、おそらくはたった一部分を見ています。

03:30.320 --> 03:34.790
メソッドの呼び出しや、システムが連動して呼び出される一連の呼び出しなどです。

03:34.790 --> 03:38.120
そして、それが意図したとおりに機能するのか、ということだ。

03:38.150 --> 03:43.280
すでに申し上げたように、私たちはプロジェクトに取り組む基本的な方法としてスモークテストを行っています。

03:43.280 --> 03:45.410
ここで簡単な例を想像してみよう。

03:45.410 --> 03:50.240
ボタンをクリックするアプリがあったとして、そのアプリにはボタンがあり、それをクリックすると勝利となる。

03:50.360 --> 03:52.730
コードを追加すればいい

03:52.730 --> 03:55.040
コンパイルして実行します。

03:55.040 --> 03:59.670
1つのボタンをクリックして、勝利のテキストが表示されるか確認してください。

03:59.690 --> 04:05.120
これはスモークテストであり、それをユーザーに伝えて、彼らがうまくいくかどうかを確認することができる。

04:05.450 --> 04:11.470
どちらの場合も、このテストは実行するにはかなりコストがかかるし、コードの使用範囲も狭い。

04:11.480 --> 04:11.810
ここで

04:11.810 --> 04:17.570
この単純な例では、すべてのユースケースを捉えることができるように思えるかもしれませんが、もっと大きなゲームを想像してみてください。

04:17.570 --> 04:19.940
コア・ループとメタル・ループがある。

04:20.210 --> 04:26.240
開発者もユーザーも、そしてユーザーも、すべてのボタン、すべてのユースケースをテストすることはできません。

04:26.240 --> 04:30.200
機能性、すべての入力と潜在的な結果のすべてをテストする。

04:30.200 --> 04:36.560
単体テストが適切に行われれば、コードを通してより多くの経路をより迅速にとらえることができる。

04:36.560 --> 04:40.550
そして、そのテスト群を時間をかけてより頻繁に自動実行することができる。

04:40.550 --> 04:44.690
テストのリストを作成し、実行できるようにする。

04:44.690 --> 04:48.050
新しいコードが古い機能を壊すことはない。

04:48.050 --> 04:54.440
チームによっては、アジャイル開発の原則の下で運営されている。

04:54.440 --> 04:55.130
スプリント

04:55.130 --> 05:01.910
例えば、2週間ごとに、1時間、1日、1週間、あるいは

05:01.910 --> 05:02.540
スプリント

05:02.540 --> 05:05.240
チームは自動化されたテストを再度実行することができる。

05:05.240 --> 05:07.610
バグを発見する絶好の機会だ。

05:07.610 --> 05:09.950
では、具体的にどのようにテストを実行するのか？

05:09.980 --> 05:13.730
Unityのエディターにはテスト機能があります。

05:13.730 --> 05:19.660
専用のウィンドウを開いて、手動でテストを実行することができます。

05:19.670 --> 05:21.220
まずはそこからですね。

05:21.230 --> 05:25.850
もちろん、これを自動化することは可能だし、大規模なプロジェクトでは推奨される。

05:25.850 --> 05:32.150
バージョン管理システムと連動させることで、コミットするたびに、あるいはコミットするたびに、そのプロジェクトにコミットすることができます。

05:32.150 --> 05:34.460
ブランチにコミットするたびにテストを実行することができます。

05:34.760 --> 05:39.170
Unity自身もUnity Cloud buildなどのサービスを提供しています。

05:39.170 --> 05:45.170
これは、テストの実行とゲームのビルドを模倣したものですが、サーバー上で自動的に実行されます。

05:45.170 --> 05:47.960
05:45.170 --> 05:47.960 --> 05:47.960

05:47.960 --> 05:52.670
さて、一般的なunityの開発では、unityの中に2つの異なるモードがあることはよく知られています。

05:52.670 --> 05:53.660
を経験する。

05:54.020 --> 05:56.870
再生ボタンを押す前は編集モードです。

05:56.870 --> 06:01.430
そのシーンが止まるまで再生ボタンを押したら、プレイモードです。

06:01.730 --> 06:05.780
unityテストでは、この2つのモードのどちらかでテストができる。

06:05.780 --> 06:07.970
そして、そのアプローチにはいくつかの異なる方法がある。

06:08.450 --> 06:13.580
あるメソッドを呼び出して、そのメソッドが次のような結果を出すかどうかを確認する。

06:13.580 --> 06:14.720
期待される結果

06:14.720 --> 06:20.720
例えば、ADDメソッドを持つ数学システムクラスがあるとしよう。

06:20.720 --> 06:22.280
その結果が既知のものと一致するかどうか。

06:22.280 --> 06:27.200
また、ED機能について特定の質問をするテストもできる。

06:27.230 --> 06:33.920
ゲームオブジェクトやカメラが適切な位置にあるときに、Edウィンドウが適切なサイズでポップアップしたか？

06:33.920 --> 06:35.480
シーンが始まる前に？

06:35.480 --> 06:41.000
できる限りテストやエディットモードを行うのがいい。

06:41.000 --> 06:41.540
プレイモード

06:41.570 --> 06:47.030
テストは非常に便利ですが、ランタイムコードの複雑さが伴います。

06:47.710 --> 06:52.900
ここでは、特定のメソッドの戻り値や結果だけでなく、そのメソッドの中でテストしているのです。

06:52.900 --> 06:57.100
ゲームオブジェクトやその他のunityコンセプトの大きなライフサイクルの中でテストしているのです。

06:57.200 --> 07:03.850
もしそうなら、ウェイクスタートのアップデートに依存するコードなどをテストすることができます。

07:03.850 --> 07:04.520
実行時にのみ実行されるもの

07:04.540 --> 07:11.320
インスタンス化されたプレハブがそのスタートメソッドを正しく実行するかどうかをテストする。

07:11.320 --> 07:12.720
例外なく。

07:12.730 --> 07:14.860
時間をかけてコードをテストできる。

07:15.580 --> 07:17.890
このループは正しく実行されていますか？

07:17.890 --> 07:19.280
数秒後

07:19.300 --> 07:21.940
実行時の物理インタラクションを確認できます。

07:21.940 --> 07:28.850
3Dゲームでボールが何回バウンドしたらバウンド要素のテストをやめますか？

07:28.870 --> 07:30.430
もう少し詳しく

07:30.430 --> 07:36.970
unityは歴史的にtest runやwindowを使ったエディタに組み込まれたテストを提供していませんでした。

07:36.970 --> 07:37.480
そうですね。

07:37.480 --> 07:43.360
Unityが発売されてから長い年月の間に、この機能は徐々に追加され、拡張されていった。

07:43.360 --> 07:45.220
Unityの最新バージョンでは

07:45.220 --> 07:50.650
必要なテストを必要な方法で実行するために必要なものは全て揃っている。

07:50.650 --> 07:56.020
ユニットテストをワークフローに追加する絶好の機会だ。

07:56.020 --> 07:56.830
07:56.020 --> 07:56.830

07:57.250 --> 07:58.090
ありがとう。
