WEBVTT

00:00.090 --> 00:01.510
ユニットテストの作成。

00:01.530 --> 00:03.600
テストクラスとテストメソッド

00:03.600 --> 00:07.260
テストメソッドを1つ含むテストクラスのコードです。

00:07.260 --> 00:12.510
内部では、arrange、act、assertというオプションのパラダイムに従っています。

00:12.510 --> 00:14.970
これは私がテストをする際に使っている規則です。

00:14.970 --> 00:19.120
テストがどのようなものか、そして既存のテストを実行する方法について見てきました。

00:19.140 --> 00:20.750
では次に、独自のテストを作成してみましょう。

00:20.760 --> 00:27.780
空のプロジェクトを開き、テスト実行ウィンドウを開き、テストフォルダとテストクラスを作成します、

00:27.780 --> 00:29.760
そしてそのテストの中にメソッドを作ります。

00:29.910 --> 00:31.740
そしてテストを実行し、結果を見ます。

00:31.740 --> 00:34.020
ここは空のプロジェクトです。

00:34.020 --> 00:37.410
unityテストフレームワークはすでに追加されています。

00:37.410 --> 00:43.920
このプロジェクトにはエディットモードのテストもプレイモードのテストもないので、テストランナーウィンドウを開いてみましょう、

00:43.920 --> 00:47.670
それぞれのタブにはいくつかのオプションが用意されています。

00:47.670 --> 00:53.610
まず、新しいフォルダを作成するボタンをクリックして、編集モードテストのアセンブリフォルダを作成します。

00:53.610 --> 00:59.430
プロジェクト・ウィンドウの中に、テスト用にセットアップされたアセンブリ、ユニティー・アセンブリ、アセンブリ

00:59.430 --> 01:07.110
定義ファイルはこのコースの範囲外ですが、簡単に言うと、これはunityの中のものが

01:07.110 --> 01:11.700
このフォルダはコンパイルされるべきであり、ユニークな方法でコンパイルされるべきである。

01:11.700 --> 01:16.470
テスト用アセンブリ・フォルダーができたので、最初のテスト・クラスを作成します。

01:16.470 --> 01:21.390
これらの各ステップはウィンドウを使わずに手動で行うこともできますが、ここでは

01:21.390 --> 01:26.610
を作成するテストスクリプトをプロジェクトウィンドウの現在のフォルダーに作成します。

01:26.610 --> 01:29.600
新しいテストクラスが作成され、2つのテストメソッドが提供されます。

01:29.610 --> 01:32.430
テスト実行ウィンドウでは、すべてが表示されています。

01:32.550 --> 01:33.930
全てのテストを実行します。

01:33.930 --> 01:35.150
全てのテストに合格

01:35.160 --> 01:37.230
生成されたコードを見てみよう。

01:37.230 --> 01:42.090
この時点で、クラス名やメソッド名は自由に変更できます。

01:42.090 --> 01:45.660
もちろん、コピー＆ペーストでメソッドを追加することもできます。

01:45.660 --> 01:50.940
テストクラスで使えるテストメソッドの数に制限はありませんが、一般的には次のように使います。

01:50.940 --> 01:57.990
クラスを使って特定のトピックを整理するのです。

01:57.990 --> 02:01.170
テストメソッドは本番の各メソッドに含まれます。

02:01.170 --> 02:03.420
そのようなテストをしたいのですね。

02:03.420 --> 02:07.110
これらのコメントはunityが自動的に生成してくれるもので、かなり役に立つ。

02:07.650 --> 02:09.120
ここでハイライトを説明します。

02:09.120 --> 02:10.380
テストの使い方

02:10.920 --> 02:19.290
test属性を使うことで、通常のエディットモードのテストが可能になります。 unity test属性を使うことで、以下のことが可能になります。

02:19.290 --> 02:22.250
複数のフレームでテストを実行することができます。

02:22.260 --> 02:26.790
さて、unity testを使うのがプレイモードに最適であることは前述した。

02:26.790 --> 02:31.320
非同期機能を使うことで、より多くのオプションを得ることができます。

02:31.320 --> 02:38.160
コメントにもあるように、yield return nullでフレームをスキップすることができます。

02:38.160 --> 02:43.020
例えば、セットアップを行い、1フレーム待ってテストを行う。

02:43.020 --> 02:44.010
そんな感じです。

02:44.010 --> 02:47.730
例えば、セットアップをやって、1フレーム待つ。

02:48.380 --> 02:51.080
そしてアサーション、みたいな。

02:51.080 --> 02:54.620
ここで、unityに戻って......タブオーバーします。

02:55.350 --> 02:57.840
プレイモードで同じ手順を踏む。

02:57.840 --> 03:04.020
まず、プレイモードのテストアセンブリフォルダを作成し、テストスクリプトを作成します。

03:04.020 --> 03:09.900
このフォルダの中に、2つのテストメソッドを含む1つのテストクラスがあることがテストランナーで確認できます。

03:10.500 --> 03:13.370
すべて実行してみると、すべてパスしていることがわかります。

03:13.380 --> 03:15.350
生成されたコードを見てみよう。

03:15.360 --> 03:21.960
ここで生成されたコードは、再生モードでも編集モードでも実は同じものです。

03:21.960 --> 03:24.240
両者のスタート地点はよく似ている。

03:24.240 --> 03:25.110
以上です。

03:26.480 --> 03:31.700
テストランナーウインドウとほんの少しCシャープを加えただけで、それが見えてきた。

03:31.700 --> 03:35.250
unityプロジェクトでできることは以前より増えました。

03:35.270 --> 03:41.420
ユニットテストの初心者であれば、unityを使ってランタイムコードを作ることには慣れていると思いますが、テストは

03:41.420 --> 03:42.800
コードをテストするのは別のことだ。

03:43.480 --> 03:46.750
エンドユーザーが直接体験することはありません。

03:47.200 --> 03:49.770
このコードはテストモードでのみ実行されます。

03:49.790 --> 03:52.320
最終的なビルドに組み込まれることもありません。

03:52.330 --> 03:59.470
私たちは今、テストを、より大きなアプリケーションのテストにおける瞬間と時間の小さな窓としてとらえ始めている。

03:59.470 --> 04:03.030
一貫した結果を得るために、焦点を絞った。

04:03.040 --> 04:08.320
今までは、既存のコードに新しいテストを追加することを主に話してきました。

04:08.350 --> 04:13.420
次は、テスト駆動開発でコードを開発しながらテストを追加する方法について見ていきます。

04:13.420 --> 04:14.200
ありがとうございました。
