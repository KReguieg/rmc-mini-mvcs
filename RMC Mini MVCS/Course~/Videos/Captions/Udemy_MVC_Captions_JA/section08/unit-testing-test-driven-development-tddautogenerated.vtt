WEBVTT

00:00.090 --> 00:01.360
テスト駆動開発

00:01.380 --> 00:04.920
テストクラスとテストメソッドの例です。

00:04.920 --> 00:08.450
このコースではすでに、既存のテストを実行する方法を見てきました。

00:08.460 --> 00:14.910
テスト駆動開発(TDD)とは、新しいテストをゼロから作成する方法です。

00:14.910 --> 00:17.550
本番のコードを追加する前にテストを追加することです。

00:17.550 --> 00:21.290
特にテストを始めたばかりの人にとっては、これは奇妙に思えるかもしれない。

00:21.300 --> 00:26.430
テスト駆動開発と伝統的な開発手法の混在が可能であることを念頭に置きながら、この手法についてさらに学んでいこう。

00:26.430 --> 00:29.490
テスト駆動開発と従来のテスト駆動開発を混ぜることもできる。

00:29.520 --> 00:36.570
TDDはテストを作成し、コードが一度作成されたら何をするのかを特定し、検証する。

00:37.110 --> 00:38.280
これがワークフローだ。

00:38.280 --> 00:44.220
新しいテストを作成し、コードがコンパイルされるように十分な実装を加える。

00:44.220 --> 00:48.610
このコードをコンパイルするのに十分な実装を追加しました。

00:48.630 --> 00:54.000
おそらく空の実装でもテストを実行し、テストは失敗します。

00:54.450 --> 00:55.590
予想通りですね。

00:55.590 --> 01:01.950
テストが失敗するのを見ることで、私たちはより自信を持つことができます。

01:01.950 --> 01:05.040
01:01.950 --> 01:05.040

01:05.040 --> 01:09.420
そして、テストがパスするまで本番コードをリファクタリングし、次に進む。

01:09.420 --> 01:16.020
TDDとは、テストが先で本番コードを書くのが後という単純な順序ではありません。

01:16.020 --> 01:19.140
プロジェクトに対する考え方でもあるのです。

01:19.140 --> 01:24.230
このうちのいくつかは、本当に実践し、結果を実感するために必要なものです。

01:24.240 --> 01:31.110
しかし、TDDの経験を重ねるにつれて感じるのは、新しいコードに対する考え方が変わってくるということだ。

01:31.110 --> 01:38.160
しかし、TDDの経験を重ねるにつれて、新しいコードに対する考え方が変わってくることがわかった。

01:38.160 --> 01:42.180
01:38.160→01:42.180）。

01:42.210 --> 01:48.840
このフローを別の見方をすれば、失敗するテストを書き、そのテストをパスさせ、そして次のようになります。

01:48.840 --> 01:51.660
そして他の目標を達成するためにコードをリファクタリングする。

01:51.660 --> 01:58.590
最適化、コーディングの標準化などを行った上で、「実際にやってみよう」と繰り返すのです。

01:58.590 --> 02:01.320
すでにテストが行われているunityプロジェクトを開きます。

02:01.320 --> 02:08.790
TDDを使って新しいテストを追加し、コンパイルするのに十分なプロダクションコードを作成します。

02:08.790 --> 02:12.090
そして合格するまでリファクタリングする。

02:13.020 --> 02:16.130
ここはかなり空のunityプロジェクトです。

02:16.140 --> 02:22.560
テストフレームワークがパッケージマネージャに追加されていることを確認しました。

02:22.560 --> 02:25.590
まずはテストを1つコピーしました。

02:25.620 --> 02:28.350
そのテストを編集モードで見てみましょう。

02:28.350 --> 02:33.780
単純な数学クラスのADDメソッドをカバレッジするテストがあります。

02:33.780 --> 02:34.850
テストを実行してみましょう。

02:34.860 --> 02:35.900
合格です。

02:35.910 --> 02:41.430
コードを見てみましょう。ここでは、以前のプレゼンテーションでお馴染みのテストを見てみましょう。

02:41.430 --> 02:45.330
では、ここで説明したテスト駆動開発をしてみましょう。

02:45.360 --> 02:51.450
数学システムの機能を拡張する場合、いくつかのアプローチがあります。

02:51.450 --> 02:57.090
本番用のコードをテストなしで作成する。

02:58.260 --> 03:01.350
その後にテストを追加するか、しないか。

03:02.530 --> 03:08.530
しかし、テスト駆動開発では、本番用のテストを追加する前に、まずテストを行います。

03:08.530 --> 03:09.040
コードを追加する。

03:09.870 --> 03:11.010
どう動くか見てみましょう。

03:11.040 --> 03:11.700
想像してみる

03:11.700 --> 03:11.880
そうだな

03:13.080 --> 03:14.040
想像してみる

03:14.040 --> 03:16.680
数学システムには減算法が必要だ。

03:17.980 --> 03:22.240
ソースコードを見ればわかるように、この抽象メソッドはまだ存在しない。

03:23.150 --> 03:24.830
しかし、とりあえずテストしてみましょう。

03:25.760 --> 03:29.060
まずはtest属性を追加します。

03:29.270 --> 03:37.130
何をテストするのか、どのような結果を期待するのか、どのような状況を想定しているのかをメソッド名にしてみます。

03:37.130 --> 03:38.390
引き算の場合

03:38.390 --> 03:40.130
結果は5となる。

03:40.160 --> 03:45.140
10と5で引けば10マイナス5は5だ。

03:45.170 --> 03:48.980
テストをセットアップするために、数学システムの新しいコピーをインスタンス化する。

03:49.220 --> 03:52.250
subtractメソッドを呼び出して結果を得る。

03:52.280 --> 03:56.830
赤い文字は、私のコードエディターがsubtractメソッドがないことを知っていることを示している。

03:56.840 --> 04:03.320
そして最後に、このメソッドが5を返すことを期待しています。

04:03.320 --> 04:04.100
をコピーして貼り付けたからである。

04:04.100 --> 04:05.060
15と書いてある。

04:05.090 --> 04:06.180
変更します

04:06.200 --> 04:08.150
これで適切な仮定がチェックされました。

04:08.840 --> 04:13.180
コンパイルできないことは分かっていますが、保存してunityに戻りましょう。

04:13.190 --> 04:14.750
2つのことに注意しよう。

04:14.750 --> 04:19.250
ひとつは、コンソールウィンドウにコンパイルエラーが表示されていることです。

04:19.250 --> 04:24.300
そして、テストランナーのウィンドウにはまだ新しいメソッドが表示されていない。

04:24.320 --> 04:26.610
これらはTDDで注意すべき良い点だ。

04:26.630 --> 04:30.970
次のステップは、コンパイルできる程度のコードを作ることだ。

04:30.980 --> 04:34.700
この段階で実装を終わらせないことが非常に重要だ。

04:34.700 --> 04:36.920
これが数学システムのソースコードです。

04:36.920 --> 04:42.050
これが一番簡単な実装です。

04:42.050 --> 04:45.740
適切な実装が終わっていないことに注意してください。

04:45.740 --> 04:52.550
さて、この例ではAとBを引き算すればよいことがわかっているので、些細なことのように思える。

04:52.550 --> 04:58.460
しかし、通常テスト駆動開発では、あるメソッドの実装はもっと複雑になる。

04:58.460 --> 04:59.540
より時間がかかる。

04:59.540 --> 05:03.470
いずれにせよ、コンパイルするのに十分な量ができたら、いつもここでストップする。

05:04.230 --> 05:05.360
テストを見てみよう。

05:05.370 --> 05:09.150
コード・エディターでsubtractが赤く表示されなくなりました。

05:09.570 --> 05:11.340
保存してunityを確認しましょう。

05:11.370 --> 05:13.710
コンソールエラーは出なくなりました。

05:13.710 --> 05:14.280
素晴らしい。

05:14.280 --> 05:15.540
すべてコンパイルされています。

05:15.540 --> 05:19.290
テストランナーのウィンドウに新しいテストメソッドが表示されました。

05:19.290 --> 05:20.430
全てのテストを実行してみましょう。

05:20.430 --> 05:26.430
1つ以上のテストメソッドが失敗したので、失敗のテストとみなすことができます。

05:26.430 --> 05:31.350
失敗したメソッドを選択すると、小さなインプットが表示される。

05:31.350 --> 05:34.200
失敗した理由を示すテキストが出力されています。

05:34.470 --> 05:38.490
5を期待していたのに、0を返している。

05:38.490 --> 05:40.560
さて、なぜこのような動作をしたのでしょうか？

05:40.560 --> 05:46.350
些細なことのように思えるかもしれないが、これは重要な違いである。

05:46.350 --> 05:49.260
をテストすることである。

05:49.260 --> 05:55.560
このテストは、適切な実装が自信を持って合格を与えるタイミングを知るための良い基礎となる。

05:55.560 --> 05:57.420
ここで適切な実装を追加しよう。

05:57.420 --> 06:02.160
最初のパラメータが2番目のパラメータより大きいと仮定し、単純に次のように返します。

06:02.160 --> 06:05.670
そして、単純にマイナスBを返す。

06:07.570 --> 06:12.600
これでテストはうまく実行され、テスト駆動開発の最初の例が完成した。

06:12.610 --> 06:13.450
これで終了。

06:13.990 --> 06:20.680
さて、私自身の経験から言うと、テスト駆動開発を本当に実感できるようになるには、時間をかけて練習する必要があった。

06:20.680 --> 06:21.520
ということだ。

06:21.520 --> 06:29.890
ユニットテスト、ユニットテストの作成、テスト駆動開発について簡単に説明しました。

06:30.580 --> 06:35.200
このように、テスト駆動開発には様々な利点があることがお分かりいただけたと思います。

06:35.200 --> 06:41.350
ここで学んだテストとMVCアーキテクチャを組み合わせることで、あなたは以下のようなツールを手に入れることができる。

06:41.350 --> 06:47.460
よりモジュール化され、スケーラブルで、最適化され、ロバストで、信頼できるプロジェクトを作るためのツールを手に入れることができる。

06:47.470 --> 06:52.610
テストと優れたアーキテクチャーの組み合わせは本当に強力だ。

06:52.630 --> 06:53.500
ありがとう。
