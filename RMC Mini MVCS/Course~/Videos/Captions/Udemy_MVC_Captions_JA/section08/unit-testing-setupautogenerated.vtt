WEBVTT

00:00.150 --> 00:03.750
テストランナーウィンドウとテストクラスのセットアップ。

00:03.750 --> 00:07.380
テストフレームワークのソースコードはパッケージマネージャーから入手できます。

00:07.380 --> 00:14.580
テストフレームワークのパッケージ検索を追加し、テストフレームワークをインポートし、オプションで

00:14.580 --> 00:15.270
コード・カバレッジ

00:15.270 --> 00:19.980
ツール Unity Testフレームワークには、CEコードのテストに必要なライブラリがすべて含まれています。

00:19.980 --> 00:25.830
個人として、あるいはチームとして、テストに慣れていない場合、すべてのコードをテストする必要はありません。

00:25.830 --> 00:26.670
00:26.670 --> 00:26.670

00:26.670 --> 00:32.550
ゆっくり時間をかけてテストを始めればいい。

00:32.550 --> 00:37.740
00:37.740 --> 00:37.860 --> 00:37.860 --> 00:37.860 --> 00:37.860

00:37.860 --> 00:44.670
新機能のためだけにテストを追加したり、大きなリファクタリングの前に主要なシステムにテストを追加する。

00:44.670 --> 00:48.780
また、バグフィックス時にテストを行うのも良い方法です。

00:48.780 --> 00:55.200
ユーザーがバグを報告したら、まず失敗したテストでバグの存在を再現する。

00:55.200 --> 00:57.930
そしてコードを修正し、テストをパスする。

00:57.930 --> 01:00.690
このテストはレガシーとして残すことができます。

01:00.690 --> 01:03.420
バグが再発することはないんだな？

01:03.420 --> 01:08.880
コード・カバレッジとは、コードベースのどれだけの部分をテストでカバーしているかという概念です。

01:09.150 --> 01:16.680
プロジェクト全体で1つのクラスと3つのメソッドがあり、その3つすべてにテストがある場合

01:16.680 --> 01:18.390
カバレッジは100%です。

01:18.390 --> 01:21.120
一般的に言って、カバレッジは高ければ高いほど良い。

01:21.120 --> 01:27.390
コード・カバレッジ・ウィンドウを開いてテストを実行すれば、以下のような結果が得られる。

01:27.390 --> 01:32.280
クラスやシステムごとのパーセンテージだけでなく、すべてのクラス内でのパーセンテージも表示される。

01:32.280 --> 01:36.900
カバレッジのあるメソッドとないメソッドが行ごとに表示されます。

01:37.320 --> 01:38.430
とても便利です。

01:38.430 --> 01:43.770
また、テスト中に脆弱性を発見することもできます。

01:43.770 --> 01:48.840
また、カバレッジの拡大を長期にわたってモニターすることもできます。

01:48.840 --> 01:54.930
これらのライブラリがインストールされた状態で、最初のテストを作成し、テスト実行ウィンドウを開き、次のように作成します。

01:54.930 --> 02:00.510
最初のクラスとメソッドを作成します。

02:00.510 --> 02:05.820
その時点で、これらのテストはテストランやウィンドウに表示されます。

02:05.820 --> 02:06.450
実行される。

02:06.450 --> 02:09.180
テストメソッドを持つテストクラスの例です。

02:09.300 --> 02:11.100
ごく普通に見えるだろう。

02:11.100 --> 02:16.980
C・シャープ 角括弧で囲んだテスト属性がミソだ。

02:16.980 --> 02:22.380
この属性でマークされたメソッドをテストとみなす。

02:22.380 --> 02:26.730
前述したように、テストは芸術であり、様々なアプローチの仕方がある。

02:26.730 --> 02:32.040
私が使っている良い方法は、それぞれのメソッドを3つのセクションに分けることです。

02:32.610 --> 02:35.310
アレンジ、アクション、アサート。

02:35.460 --> 02:39.960
arrangeではテストをセットアップするために必要な行を1つ以上書きます。

02:39.960 --> 02:45.750
actの部分で、テストに関連することを実行する。

02:45.750 --> 02:46.560
アサート

02:46.560 --> 02:49.530
アサートとは何かが真実であると仮定することです。

02:49.530 --> 02:52.410
テストフレームワークはassertライブラリで提供される。

02:52.410 --> 02:55.920
2つの数字を足し算する数学のシステムがあるとしよう。

02:55.920 --> 02:56.550
一緒に

02:56.550 --> 03:03.930
5と10の和は15になる。

03:04.050 --> 03:06.200
テストが成功したとみなす。

03:06.210 --> 03:07.650
実際にやってみよう

03:07.650 --> 03:10.620
テストの準備ができたunityプロジェクトを開いてみます。

03:10.710 --> 03:14.010
どのように動作するか見て、テストを実行します。

03:15.110 --> 03:17.630
ここは空のunityプロジェクトです。

03:17.630 --> 03:20.360
テストフレームワークのセットアップから始めます。

03:20.510 --> 03:22.370
パッケージマネージャーを開きます。

03:26.970 --> 03:30.980
パッケージマネージャーには既にインストールされているパッケージが表示されます。

03:30.990 --> 03:36.660
あなたが始めたプロジェクトには既にテストフレームワークが追加されている可能性があります。

03:37.390 --> 03:40.070
しかし、もしそうでなければ、自分で追加する方法を紹介しよう。

03:40.090 --> 03:44.890
Unityレジストリでtest frameworkを検索し、最新版をインストールします。

03:44.890 --> 03:52.630
次にオプションの追加機能について、Unityレジストリでコードカバレッジを検索し、コードをインストールします。

03:52.630 --> 03:54.400
coverageにはいくつかのオプションサンプルがあります。

03:54.400 --> 03:55.870
ここではインストールしません。

03:56.760 --> 04:02.160
プロジェクトに含まれるパッケージを見直してみると、テストフレームワークとオプションのifがあります。

04:02.160 --> 04:04.160
をインストールすることもできます。

04:04.170 --> 04:07.290
これでこのプロジェクトはユニットテストに完全に対応した。

04:09.140 --> 04:09.860
さあ、始めましょう。

04:09.860 --> 04:11.630
テストランナーのウィンドウを開きます。

04:12.050 --> 04:16.340
テストランナーウィンドウには編集モードと再生モードの2つのタブがあります。

04:16.580 --> 04:18.200
まだテストは追加されていません。

04:18.230 --> 04:23.210
このウインドウはとても便利で、テストを作成するためのクリック可能な作成オプションがいくつか用意されている。

04:23.240 --> 04:26.690
この後のデモでは、テストをゼロから作成する方法を紹介する。

04:27.050 --> 04:30.260
とりあえず、すでに用意したものを貼り付けてみる。

04:31.220 --> 04:35.960
このテストはMini MVCsのサンプルプロジェクトから貼り付けたものです。

04:35.960 --> 04:36.920
コースのため。

04:36.920 --> 04:40.450
集中力を高めるために、見たいテスト以外はすべて削除しました。

04:40.460 --> 04:45.130
まずはエディット・モードから。

04:45.140 --> 04:49.580
デフォルトでは、プロジェクト内のすべてのテストがこのedit modeタブに表示されます。

04:49.580 --> 04:55.820
デフォルトでは、assetsフォルダとpackagesフォルダのどこでも利用可能なすべてのテストが表示されます。

04:55.820 --> 04:59.780
カテゴリで絞り込むと、一部のテストだけを表示することができます。

04:59.780 --> 05:04.880
あまり多くのテストはありませんが、デモのためにサンプルのカテゴリーを選択します。

05:04.880 --> 05:08.720
このウィンドウには、ネームスペースごとに階層化されたテストが表示されます。

05:08.720 --> 05:15.470
下の階層をすべて展開すると、テストクラスが表示され、その下にテストメソッドが表示される。

05:15.470 --> 05:18.470
すべてのテストを実行し、パスすることを確認できる。

05:18.650 --> 05:22.130
個々のテストを選択して実行することも可能です。

05:22.130 --> 05:26.960
テストが合格でも不合格でも、右クリックで簡単にソースコードを見ることができる。

05:26.960 --> 05:27.560
メニューにアクセスします。

05:30.280 --> 05:31.930
これが完全なテストコードです。

05:32.290 --> 05:35.120
これはプレゼンテーションで見たものと同じです。

05:35.140 --> 05:36.360
ハイライトを見てみよう。

05:36.370 --> 05:40.990
オプションのcategory属性はテストを整理するのに役立ちます。

05:41.290 --> 05:46.930
このドロップダウンは、この値に基づいてフィルタリングを行うもので、多くのテストクラスを

05:46.930 --> 05:48.040
同じカテゴリーに

05:48.040 --> 05:50.950
05:50.950→05:50.950→05:50.950→05:50.950→05:50.950

05:50.950 --> 05:52.450
次にテスト属性です。

05:52.450 --> 05:57.190
これはテストフレームワークに対して、このメソッドがテストメソッドであることを示すものです。

05:57.990 --> 06:00.740
これがないと、テストランナーのウィンドウには表示されません。

06:00.750 --> 06:07.710
次に、おなじみだがオプションのパラダイムであるレンジアクトを使う。

06:07.710 --> 06:10.170
これは私がテストロジックを整理するために使っている方法である。

06:10.170 --> 06:16.350
また、テストに名前をつけるときは、何がテストの対象になっているのか、何を期待しているのかに基づいて名前を決めている。

06:16.350 --> 06:17.640
どんな状況なのか。

06:17.640 --> 06:24.120
ここではオペランドとして5と10を渡したときに結果が15になることをADDメソッドでテストしている。

06:24.120 --> 06:25.890
プレイモードにタブオーバーしてみましょう。

06:25.890 --> 06:31.410
プレイモードのタブはよく似ていて、全く同じテストが表示されているように見えますが、そうではありません。

06:31.410 --> 06:32.370
ソースを開きます。

06:32.370 --> 06:34.350
プレイモードのテストのソースコードです。

06:34.350 --> 06:35.610
どう違うんだ？

06:35.610 --> 06:40.320
主な違いは、プロジェクトウィンドウのどこにあるかということです。

06:40.440 --> 06:41.640
すぐにお見せします。

06:41.640 --> 06:47.610
オプションで、プレイモードのテストにはプレイモードのクラスを追加しています。

06:47.610 --> 06:53.010
edモードではtestとつけるだけだが、これは整理するのに便利だ。

06:53.010 --> 06:58.980
デモのために、まったく同じ動作をエディットモードとプレイモードで試している。

06:58.980 --> 07:01.290
その必要はないだろう。

07:01.290 --> 07:08.280
その代わり、編集モードではデフォルトでテストし、プレーをキャプチャする必要があるときだけプレーモードのテストを使います。

07:08.280 --> 07:15.690
プレイモードのテストは、ゲームオブジェクトの機能、衝突の検出、その他のテストなど、プレイモードのイベントをキャプチャする必要がある場合にのみ使用します。

07:15.690 --> 07:16.980
実行時のみ発生します。

07:16.980 --> 07:21.180
コースで説明したように、私は以前見たのと同じメソッドの命名規則を使っている。

07:21.180 --> 07:22.170
2つ書いておこう。

07:22.320 --> 07:24.330
ここで2つの重要な違いに注意しよう。

07:24.330 --> 07:31.320
以前見たように、テスト属性ではなく、ユニティーテスト属性を使用しています。

07:31.320 --> 07:34.470
actとassertに加え、オプションでweightというパラダイムがあります。

07:34.470 --> 07:41.160
これは、編集モードのテストが同期的に実行されるという事実を示すために使用されています。

07:41.160 --> 07:44.670
モードのテストは非同期に実行される。

07:44.670 --> 07:49.860
つまり、非同期テストが必要なコードがあれば、playモードは素晴らしい選択肢となる。

07:49.860 --> 07:52.620
プロジェクトウィンドウの構成を見てみましょう。

07:52.620 --> 07:58.080
エディットモードのテストはエディターフォルダーにあり、プレイモードのテストはランタイムにあることに注目してください。

07:58.080 --> 07:58.500
フォルダにある。

07:58.500 --> 08:05.310
この違いは、これらのテストに隣接するアセンブリ定義ファイルの違いと合わせて、次のようになる。

08:05.310 --> 08:09.870
この違いは、エディターテストとプレイモードテストの違いである。

08:09.870 --> 08:11.370
プレイモードのテストを実行します。

08:11.370 --> 08:13.460
最後にプレイモードのテストを行います。

08:13.470 --> 08:18.840
テストランナーウィンドウの挙動は同じだが、プレイモードのテストであるため、1つの例外がある。

08:18.840 --> 08:25.710
Unityは匿名シーンを作成し、テストを単独で実行した後、シーンを破棄します。

08:25.740 --> 08:31.710
この処理は非常に高速に行われますが、ここではプラスアルファの処理として、すべてのプレス実行が行われていることに気づくでしょう。

08:31.710 --> 08:34.680
を押すと、すべてのテストが1ミリ秒で実行される。

08:34.680 --> 08:39.600
例えば、編集モードがここで行うかもしれないが、実行に数ミリ秒かかる。

08:39.600 --> 08:46.220
テストランナーのウィンドウが表示され、基本的なテストが実行されているのがわかります。

08:46.230 --> 08:48.990
次に、独自のテストを作成する方法を見てみよう。
