WEBVTT

00:00.150 --> 00:03.690
オブザーバーからデザインパターンを見てみよう。

00:03.720 --> 00:11.100
デザイン・プリンシプルが理論的に非常に高い位置にあるのに対して、デザイン・パターンはもう少し高い位置から始まります。

00:11.100 --> 00:14.370
コンピュータサイエンスと具体的な解決策に基づくものである。

00:14.400 --> 00:16.450
デザインパターンは言語にとらわれない。

00:16.470 --> 00:22.080
同じパターンを様々なプログラミング言語やプラットフォームに適用できるのです。

00:22.080 --> 00:28.050
デザインパターンは、設計上の問題に対する再利用可能な解決策の一種と考えることができます。

00:28.080 --> 00:32.550
さて、あなたのプロジェクトでは、そのプロジェクト特有のことがたくさんあると思います。

00:32.550 --> 00:38.580
ゲームのニーズはもちろんですが、様々な問題が発生し、それをどのように整理する必要があるのか。

00:38.580 --> 00:41.160
ソフトウェアでは以前から行われてきたことです。

00:42.090 --> 00:45.750
デザインパターンを使うことの利点は、実績があるということです。

00:46.260 --> 00:51.450
デザインパターンを使うことの利点は、実績があるということです。

00:51.450 --> 00:56.530
そうすれば、開発のスピードも上がるし、メンテナンスも簡単になる。

00:56.550 --> 00:59.970
ここで、最もポピュラーなデザインパターンのリストを見てみましょう。

01:00.150 --> 01:04.620
他にもたくさんありますし、独自のデザインパターンを定義することもできます。

01:04.620 --> 01:10.380
しかし、ここで約20のデザインパターンを知っておくことで、自分のデザインパターンを考えるためのライブラリとして活用することができます。

01:10.380 --> 01:11.220
プロジェクトに参加することができる。

01:11.220 --> 01:15.270
大きく分けて3つのタイプがある。 新しいものを作る創造的なパターン。

01:15.270 --> 01:22.950
構造パターンとは、そのシステムをどのように構築するかを整理するものであり、行動パターンとは、そのシステムがどのように機能するかを定義するものである。

01:22.950 --> 01:24.270
そして行動パターンとは、これらのシステムが互いにどのように振る舞うかを定義するものである。

01:24.450 --> 01:30.540
そのうちのいくつかは、これから見ていくアーキテクチャーに直接関係するものなので、詳しく見ていくことにする。

01:30.540 --> 01:31.290
をご覧下さい。

01:31.290 --> 01:37.290
特にユニット開発者としては、すでに使っていることだろう、

01:37.290 --> 01:39.030
オブザーバー・パターンです。

01:39.030 --> 01:44.040
Observerパターンは、複数のオブジェクトがどのように通信するかを定義します。

01:44.040 --> 01:49.290
クラスが2つ目のクラスへの参照を取得し、そのクラスに対して直接メソッドを呼び出すことができます。

01:49.290 --> 01:53.480
そして、どのメソッドを呼び出せばいいのかを正確に知る必要がある。

01:53.490 --> 01:58.200
これが密結合の例です。

01:58.200 --> 02:01.980
オブザーバーの利点は、それほど緊密な関係ではないということです。

02:01.980 --> 02:08.760
クラスは送り手への参照を必要としますが、より簡単にデータを交換し、分離することができます。

02:08.760 --> 02:12.360
を変更することで発生する問題を切り離すことができる。

02:12.360 --> 02:18.840
また、複数のオブザーバーを持つことができ、このパターンを経るにつれて簡単に追加したり削除したりすることができる。

02:18.840 --> 02:24.210
を理解するためにUMLについて学んだことを応用してみましょう。

02:24.870 --> 02:29.730
そして、これらのパターンのそれぞれについて、さらなる研究をする絶好の機会がある。

02:29.940 --> 02:32.520
これはユニティのオブザーバーの例です。

02:32.520 --> 02:38.190
さて、unityでこれを解決する方法はいくつかあるのですが、まず第一の解決方法として、あなたはきっと

02:38.190 --> 02:41.490
unityでおなじみのunityイベントです。

02:41.790 --> 02:48.510
イベントの作成、イベントのリスニング、イベントの呼び出しの3つの主要な部分があります。

02:48.510 --> 02:49.230
イベントを呼び出す。

02:49.260 --> 02:50.630
すべてここに表示されています。

02:50.640 --> 02:58.320
通常は2つ以上のクラスにまたがるが、ここでは簡潔にするために1つのクラスを示す。

02:58.320 --> 03:00.540
いわば自分自身の声を聞いているようなものだ。

03:00.540 --> 03:06.030
さて、最後の例はunityに組み込まれたものでしたが、これはカスタムクラスです。

03:06.030 --> 03:07.230
コードに入ります。

03:07.230 --> 03:13.020
このクラスは、Unityのイベントと同じコンセプトをobservableクラスに取り入れたものです。

03:13.020 --> 03:13.440
これです。

03:13.440 --> 03:21.240
このobservableの例では、observableを作成し、observableをリッスンし、observableを呼び出すことができます。

03:21.240 --> 03:22.380
そのobservableを呼び出す。

03:23.320 --> 03:30.430
特にデータをゲームロジックの他の部分から切り離す場合には、よくあるパターンだ。

03:30.430 --> 03:33.770
データが変更されたときにサブスクライブするためのものです。

03:33.790 --> 03:39.420
このobservableクラスは、observerパターンと結びつけるとても簡単な方法です。

03:39.430 --> 03:41.560
どのような時間の変化でも

03:41.560 --> 03:43.510
このコードでその様子を見ることができる。

03:43.510 --> 03:45.230
そして最後の例のように

03:45.250 --> 03:51.640
通常は2つ以上のクラスを使って完全なデモを行うが、簡潔にするために1つのクラスにしてみた。

03:51.640 --> 03:52.210
ファイル

03:52.540 --> 04:00.100
Observerパターンはとても基本的で、もしあなたがそれを十分に使っていることに気づいたら、とても有益なものです。

04:00.100 --> 04:03.790
しかし、それを理解していなかったり、活用できていないと感じているのであれば、それはとても基本的で有益なことなのです。

04:03.910 --> 04:06.180
もっとチェックした方がいい

04:06.190 --> 04:09.610
この後サンプルでやるいくつかの例で見ることができるだろう。

04:09.610 --> 04:16.570
また、UnityプロジェクトにプラグインされたさまざまなAPIやSDKでも見ることができます。

04:16.570 --> 04:22.360
このように、コードのさまざまな領域を分離することは、非常にシンプルで強力なことです。

04:22.360 --> 04:23.580
それは、いくつかの利点をもたらすでしょう。

04:23.590 --> 04:24.340
ありがとう。
