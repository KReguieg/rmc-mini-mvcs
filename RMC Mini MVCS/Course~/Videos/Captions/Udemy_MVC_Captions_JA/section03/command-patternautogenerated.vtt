WEBVTT

00:00.180 --> 00:02.800
コマンドのデザインパターンを見てみよう。

00:02.820 --> 00:05.390
コマンドはビヘイビアデザインパターンです。

00:05.400 --> 00:09.210
observerと似ていますが、十分違います。

00:09.210 --> 00:11.340
独自のパターンである。

00:11.430 --> 00:17.730
また、このパターンを使用するメリットとして、実行やアンドゥの機能があります。

00:17.730 --> 00:23.360
多くのチームがUIにアンドゥ機能を持たせるために導入している。

00:23.370 --> 00:30.600
しかし、そのようなパラダイムを抜きにしても、オブザーバーの利点を享受できるという点では、非常に大きな成功を収めている。

00:30.600 --> 00:37.530
オブザーバー・パターンと比べると、もう少しデカップリングと抽象化が進んでいる。

00:37.530 --> 00:40.020
を参照する必要がない。

00:40.020 --> 00:47.790
その代わりに、送信者とオブザーバーはメッセージングシステムのようなものを知っている。

00:48.480 --> 00:51.510
後のコードではこれをコマンド・マネージャーと呼ぶ。

00:51.510 --> 00:57.780
スコープがコマンドマネージャーに到達できる限り、コマンドマネージャーはスコープと通信の仲介役となる。

00:57.780 --> 01:03.990
そして、オブザーバーと同じように、データ交換とコミュニケーションを可能にする、

01:03.990 --> 01:07.410
片方が変われば、もう片方も変わる必要があるのか？

01:07.410 --> 01:11.720
また、複数のオブザーバーを簡単に追加したり削除したりすることも可能です。

01:11.730 --> 01:12.270
そうだな

01:12.270 --> 01:15.600
先ほどのオブザーバーの例と平行ですね。

01:15.600 --> 01:22.640
コマンドシステムの作成、リスナーの追加、そしてコマンドシステムの起動です。

01:22.650 --> 01:28.230
さて、通常は2つ以上のクラス間でコマンドを送信することになるが、簡潔にするために以下のように記述した。

01:28.230 --> 01:29.760
を1つのクラスファイルにまとめた。

01:29.760 --> 01:33.380
こうすることで、完全な機能例をすぐに見ることができます。

01:33.390 --> 01:37.710
では、もう少しパターンを挙げていきます。

01:37.860 --> 01:44.730
次に紹介するのは、MVCアーキテクチャの精神に則ったものです。

01:44.730 --> 01:45.570
の精神に則ったものです。

01:45.570 --> 01:48.960
その一つがシングルトンパターンです。

01:48.960 --> 01:55.710
これは、あるシステムをコード内で一度だけ作成し、グローバルにアクセスできるようにするものです、

01:55.710 --> 01:57.990
それはシングルトンパターンに最適な場所です。

01:57.990 --> 02:05.010
最近のUnityのアップデートでは、ネイティブのソリューションがいくつか用意されていますが、従来はコミュニティを使っていました。

02:05.010 --> 02:13.440
をベースとしたシングルトンモノビヘイビアクラスを使用していました。

02:13.440 --> 02:14.420
他のデータ型

02:14.430 --> 02:21.450
第二に、ファサード・パターンは一連のサブシステムの複雑さを軽減するのに役立つ。

02:21.540 --> 02:28.050
例えば、入力システム、レンダリングシステム、物理システムなど、すべてあなたのために作られたとしましょう。

02:29.790 --> 02:35.940
|にできるようにあなたがそれをすることができます本当に出くわすことあなたは、実際には私のパートナーとi約束、誰でも素早くはちょうど無視これらの一見正確にどのように{}人のことを忘れることができます。

02:35.940 --> 02:39.960
を呼び出すことができる。

02:39.960 --> 02:43.890
開発者の用語では、これをラップ機能と呼ぶことが多い。

02:43.890 --> 02:49.560
つまり、使いやすいように3つのシステムを1つのクラスにラップしたと言えるかもしれない。

02:49.560 --> 02:53.010
MediatorとProxyの2パターンを追加。

02:53.010 --> 02:59.700
メディエーターとプロキシは別パターンですが、メディエーターとプロキシは同じ意味で使います。

02:59.700 --> 03:05.130
つまり、ある種の仲介者がコミュニケーションの間に立つことで、いくつかの利点があります。

03:05.130 --> 03:09.330
この2つのクラスのどちらかを簡単に変更することができる。

03:09.330 --> 03:15.150
この例では、中間管理職をいじれば、システムを大幅にリファクタリングする必要はない。

03:15.150 --> 03:17.070
つまり、変化を緩和する方法なんだ。

03:17.070 --> 03:19.980
このようなコンセプトのいくつかは、後のアーキテクチャで見ることができるだろう。

03:19.980 --> 03:26.280
デザインパターンについて簡単に説明すると、デザインパターンは再利用可能なソリューションである。

03:26.280 --> 03:30.540
ゲーム開発でよく出てくるデザイン上の課題を解決するのに役立ちます。

03:30.540 --> 03:36.030
UnityではSingletonが一番馴染みがあるかもしれませんが、よく議論されるように、オブザーバーは

03:36.030 --> 03:42.840
パターンが初心者の開発者にとって最も有用であることは間違いないでしょう。

03:42.840 --> 03:47.820
この後、アーキテクチャについて見ていくことになる、

03:47.820 --> 03:51.600
このような用語が使えるようになり、皆さんも少しは理解できるようになるでしょう。

03:51.900 --> 03:57.150
このセクションのまとめとして、ハイレベルなソフトウェア設計のコンセプトをいくつか見てきました。

03:57.150 --> 04:04.470
設計原則は課題を解決するための哲学であり、UMLは図解とコミュニケーションの方法である。

04:04.470 --> 04:05.790
私たちのアイデアについて。

04:05.790 --> 04:11.580
そして、いくつかのデザインパターン、特にobserverとcommandを見てみた。

04:11.580 --> 04:12.180
このことはまた後ほど。

04:12.180 --> 04:15.640
そして、これらはプロジェクト内のコミュニケーションをデカップリングする素晴らしい方法です。

04:15.660 --> 04:17.880
次にアーキテクチャについて。

04:17.880 --> 04:23.430
ここでは、利用可能なソリューションのいくつかと、それぞれの長所と短所を見ていきます。

04:23.430 --> 04:28.290
unityに特化した人気のフレームワークをいくつか紹介します。

04:28.440 --> 04:29.370
ありがとう。
